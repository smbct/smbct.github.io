---
title:  Assembly x86 programming 101 &#58 part 7, ASCII Mandelbrot
author: smbct
date:   2024-06-28 10:00:00 +0200
categories: low-level programming assembly
comments: true
layout: series_article
back_page: headline.md
---

Although we already covered numerous basics in x86 assembly so far, one thing that has not been discussed yet is the use of **floating point** computation : namely numbers with a **decimal** part.
As we are used to working with computers, we love integers ü•∞! No rounding, no loss of precision, no [absorption problems](https://softwareengineering.stackexchange.com/questions/310173/floating-point-absorption-phenomena-and-ulp), etc..
Unfortunately, non-integer values arise in many real world problems hence it is rather useful to know a little bit about them.

In this post, we will write a program that draws an ASCII version of the Mandelbrot set.
The Mandelbrot set is a famous fractal that has been intensively rendered on computers in all of its shapes : with colors, in 3d, etc..
Its computation however relies on complex numbers arithmetic, it is hence necessary to manipulate floating point numbers.
We will see here how to draw an [ASCII](https://en.wikipedia.org/wiki/ASCII_art) version of this fractal by relying on some basic floating point number operations in assembly. 

![The Mandelbrot set](https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Mandel_zoom_00_mandelbrot_set.jpg/1920px-Mandel_zoom_00_mandelbrot_set.jpg)
<span style="font-size:0.7em;">A colorized version of the Mandelbrot set.</span>

## Floating point operations in x86 assembly

Manipulating non-integer numbers is a whole new world in assembly programming.
Indeed, these numbers are coded as "floating points" (hence their name), meaning the bits that code them are decomposed into 2 parts : the mantissa and the exponent.
The mantissa is an integer that is to be multiplied by a negative power, hence the exponent.
Usually, as numbers are coded in binary, the base 2 is used for the exponent.

![A visualisation of how decimal numbers are represented.](https://numeral-systems.com/media/ieee-754/ieee-754-floating-point.webp)
<span style="font-size:0.7em;">A visualisation of how decimal numbers are represented. Image coming from [this site](https://numeral-systems.com/ieee-754-converter/).</span>

Floating points operations in processors are performed by a dedicated component called the [**F**loating **P**oint **U**nit](https://en.wikipedia.org/wiki/Floating-point_unit) (FPU).
Hence, the assembly arithmetic instructions are completely separated from their analog integer ones. 

### How do floating points operations work in C ?

One possible source of inspiration to see how we can perform theses operations is to look at the assembly codes generated by gcc from a C code that performs floating pointes operations.
Let's start with a simple example :

<div class="code_frame"> C language | floating_points.c </div>
{% highlight C linenos %}
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char* argv[]) {

    double nbf = 0.25;
    nbf = nbf * 0.5;
    printf("result: %f\n", nbf);

    return 0;
}
{% endhighlight %}

You can compile with GCC and run this program to verify that the printed value is *0.125*.
In thi example, we work with double prevision floating point numbers, meaning these numbers are coded on 8 bytes.

We can now use GCC to produce x86 assembly code from the C program with the following command : `gcc -S floating_points.c -masm=intel -fdiagnostics-color=always -fverbose-asm -o floating_points.s`.
This command allow to create an assembly source file by using the same syntax as the one we employ, and by adding useful information regarding the original C code.

Without going into all the details of the resulting file, we can have a look at the comments referring to the 3 lines of our main function :

<div class="code_frame"> assembly x86 | floating_points.s </div>
{% highlight nasm linenos %}
; floating_points.c:9:     double nbf = 0.25;
movsd	xmm0, QWORD PTR .LC0[rip]	; tmp84,
movsd	QWORD PTR -8[rbp], xmm0	; nbf, tmp84

; floating_points.c:11:     nbf = nbf * 0.5;
movsd	xmm1, QWORD PTR -8[rbp]	; tmp86, nbf
movsd	xmm0, QWORD PTR .LC1[rip]	; tmp87,
mulsd	xmm0, xmm1	; tmp85, tmp86
movsd	QWORD PTR -8[rbp], xmm0	; nbf, tmp85

; floating_points.c:13:     printf("result: %f\n", nbf);
mov	rax, QWORD PTR -8[rbp]	; tmp88, nbf
movq	xmm0, rax	;, tmp88
lea	rax, .LC2[rip]	; tmp89,
mov	rdi, rax	;, tmp89
mov	eax, 1	;,
call	printf@PLT	;
{% endhighlight %}

#### Vector registers

Let's focus on the first part, that consists in loading the value `0.25` in the variable.
We see a new kind of register here with `xmm0`.
This register is actually part of a set of registers called [vector registers](https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions).
These registers are employed for high performances floating point operations as they allow to perform the same operation on multiple floating point values at the same time!

In this part, we will however only see how to use them when dealing with a single value.
We can see that the content of these registers can be stored in memory as we would do for other registers with the dedicated operation `movsd`.
In this case, as we declared a `double` variable in our C code, the value will be manipulated as a 8 bytes value (double precision).


#### Binary representation

One interesting aspect of this code is that it helps understanding how the floating point numbers are coded.
To see this, we can look at line 2 where the decimal value (*0.25*) is loaded from memory to the `xmm0` register.
We can have a look at the symbol `.LC0` where the value is coded :

<div class="code_frame"> assembly x86 | floating_points.s </div>
{% highlight nasm linenos %}
.LC0:
  .long	0
  .long	1070596096
  .align 8
{% endhighlight %}

At first, this does not look like our decimal value at all ! üòØ
The thing is, the value is indicated as an integer (and we will see later how it can be indicated as a classical decimal number).

To better understand how the integer value (base 10) `1070596096` can represent our `0.25`, we can refer to this [website](https://numeral-systems.com/ieee-754-converter/) that gives information about how these numbers are coded.
By entering the value *0.25* and by selecting the 64 bits mode (8 bytes), we can see the binary code of the encoded number as well as the hexadecimal √©quivalent, which is `0x3FD0000000000000` in this case.
By converting it into decimal we end up with the value ??? [TODO]

#### Arithmetic operations

If we now look at the following lines, we can see the an example the floating point version of the multiplication ‚úñÔ∏è with `mulsd` (for 8 bytes values).
Although this look like an analog version of the integer operations, they are actually different as the floating points numbers are not coded the same way as integers.
For this reason, floating point multiplications are much slower than integer ones.


#### Calling convention

With a call to `printf` in our previous code, we can see an example of the calling convention with the presence of floating point numbers.
We can see that the `rdi` register contains the string that is printed before showing the decimal value, that does not change from our previous experience.
However, the decimal value is then not placed on the usual registers `rsi`, that follows for passing parameters.
Instead, the first vector register `xmm0` is used.

Previously, we have seen that the `eax` register must be set to 0 in order to call `printf`.
That is because we did not use any vector registers, as this register actually indicate how many of them are used.
This time, it is set to the value 1 as we use one of them.


## The ASCII Mandelbrot set

We now enter the second part of the chapter : drawing the ASCII Mandelbrot set.
We will draw it in the terminal in ASCII, meaning the "pixels" will be represented by text characters.
This will be the simplest form of such drawing as no colors or shading will be used.

### The Mandelbrot set ? ü§î

The Mandelbrot set is a set of points defined on the [complex plane](https://en.wikipedia.org/wiki/Complex_plane).
Drawing this set allow to discover a very complex mathematical object with chaotic borders.

We will draw a grid of characters to represent this set.
Each character of the grid will represent the 2d coordinate of a point in the complex plane.
We will define a function that, for each of the point, indicate if it belongs to the Mandelbrot set or not.

In order to avoid spending too much time on the mathematical aspects, we will use the na√Øve algorithm presented on [this page](https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set) and simply translate it into assembly :

<div class="code_frame"> pseudocode | from wikipedia : Plotting_algorithms_for_the_Mandelbrot_set </div>
{% highlight plaintext linenos %}
for each pixel (Px, Py) on the screen do
    x0 := scaled x coordinate of pixel (scaled to lie in the Mandelbrot X scale (-2.00, 0.47))
    y0 := scaled y coordinate of pixel (scaled to lie in the Mandelbrot Y scale (-1.12, 1.12))
    x := 0.0
    y := 0.0
    iteration := 0
    max_iteration := 1000
    while (x*x + y*y ‚â§ 2*2 AND iteration < max_iteration) do
        xtemp := x*x - y*y + x0
        y := 2*x*y + y0
        x := xtemp
        iteration := iteration + 1
 
    color := palette[iteration]
    plot(Px, Py, color)
{% endhighlight %}

In this algorithm, you may realize that the complex numbers are not properly present since their real part *x* and their imaginary part *y* are stored separately.
This will actually simplify the assembly implementation as complex numbers are not natively present.

We can see that the first step is the computation of initial points scale from the "pixel" coordinates into the complex plane coordinates.
Then, for each scaled point, the test consists in studying the convergence of a sequence üåÄ that depends on the coordinates.
In this algorithm, the number of iteration is used to assign a color to the pixel.
In our cas, we will simply return a boolean value that indicates if wether the function has converged or not for a given initial value.  

### The drawing function

To organize our code, we will proceed similarly to the previous chapter by separating our code into different functions and into different files.
We will start by writing a function `draw_mandelbrot` that iterate over a grid of characters that tests if the associated point belongs to the Mandelbrot set or not :

<div class="collapse-panel"><div>
<label for="code_1">Expand</label>
<input type="checkbox" name="" id="code_1"><span class="collapse-label"></span>
<div class="extensible-content">
<div class="code_frame"> x86 assembly | draw_mandelbrot </div>
{% highlight nasm linenos %}
; draw the ascii mandelbrot set
; edi: width
; esi: height
draw_mandelbrot:

    push rbp
    mov rbp, rsp

    ; stack allocation
    sub rsp, 40 ; 32 + 8
    ; width: rbp-4, 4 bytes
    ; height: rbp-8, 4 bytes
    ; row index: rbp-12, 4 bytes
    ; col index: rbp-16, 4 bytes
    ; x0 mandelbrot: rbp-24, 8 bytes
    ; y0 mandelbrot: rbp-32, 8 bytes

    ; store the parameters
    mov [rbp-4], edi
    mov [rbp-8], esi

    ; preserving registers
    push rdi
    push rsi
    push rbx

    mov [rbp-20], dword ptr 0
    .L_for_row:

        ; compute y0
        ; [...]

        mov [rbp-16], dword ptr 0
        .L_for_col:

            ; compute x0
            ; [...]

            ; test the point convergence
            ; [...]

            test ax, ax
            jnz .L_if_not_converge 

            ; .L_if_converge:

                ; print a star
                mov rax, 1
                mov rdi, 1
                lea rsi, [star_character]
                mov rdx, 1
                syscall

                jmp .L_end_if_converge

            .L_if_not_converge:

                ; printing a space
                mov rax, 1
                mov rdi, 1
                lea rsi, [space_character]
                mov rdx, 1
                syscall

            .L_end_if_converge:

            inc dword ptr [rbp-16]
            mov eax, [rbp-4]
            cmp eax, [rbp-16]
            jne .L_for_col

        ; print a line return
        mov rax, 1
        mov rdi, 1
        lea rsi, [new_line]
        mov rdx, 1
        syscall

        inc dword ptr [rbp-12]
        mov eax, [rbp-8]
        cmp eax, [rbp-12]
        jne .L_for_row

    ; restoring preserved registers
    pop rbx
    pop rsi
    pop rdi

    mov rsp, rbp
    pop rbp

    ret

.data

star_character:
    .word '*'
space_character:
    .word ' '
new_line:
    .word '\n'

; complex plane bounds
; [...]
{% endhighlight %}
</div></div></div>

The function takes as parameters the width and the height of the character grids.
Its structure is similar to what we saw in previous chapters : there are two nested loops to iterate over the rows and the columns respectively.
Then, for each coordinate of the grid, the corresponding x0 and y0 values of the complex plane are computed.
After that, the algorithm calls a function that tests the convergence of the point and draws a character accordingly.

Our first step to compute the function is to add as constants the bounds of the complex plane.
The values are taken from the pseucode of the Wikipedia page.
They can be defined directly as floating point values the following way :

<div class="code_frame"> x86 assembly </div>
{% highlight nasm linenos %}
; complex plane bounds
min_x:
    .double -2.00
max_x:
    .double 0.47
min_y:
    .double -1.12
max_y:
    .double 1.12
{% endhighlight %}

We can then implement the computation of the floating points values x0 and y0.
Starting with y0, what we need is to convert the column index into a decimal value between 0 and 1.
Then, this value can be scaled in order to be lie in the provided bounds ([-1.12, 1.12]).

This step requires to simultaneously interact with floating point values and integer values (the column index in the grid height).
To convert an integer value into a floating point value, we will used the `cvtsi2sd` instruction which can be compared to a **cast** in C. 


### The convergence computation

#### More on branching : comparing decimal values

In GDB, to look at the `eflags` register : `p $eflags`. Discuss flags after compare instruction.

[which jump operation to use ?](https://stackoverflow.com/questions/7057501/x86-assembler-floating-point-compare)

Another post on [comparisons](https://stackoverflow.com/questions/7057501/x86-assembler-floating-point-compare) with floating point arithmetic. 

[another ressource](http://www.ray.masmcode.com/tutorial/fpuchap7.htm#fcomex)

### Result

<div class="code_frame"> Bash </div>
{% highlight plaintext linenos %}
                                                         ******                 
                                                         ******                 
                                                           ***                  
                                               **  ******************           
                                                ***************************     
                                            *******************************     
                                          * *********************************   
                           *    *         ***********************************   
                           ***********   ***********************************    
                         *************** ***********************************    
                     *** *************************************************      
                     *** *************************************************      
                         *************** ***********************************    
                           ***********   ***********************************    
                           *    *         ***********************************   
                                          * *********************************   
                                            *******************************     
                                                ***************************     
                                               **  ******************           
                                                           ***                  
                                                         ******                 
                                                         ******                 
{% endhighlight %}
                                                                                


## What's next ?