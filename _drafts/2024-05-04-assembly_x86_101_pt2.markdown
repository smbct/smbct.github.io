---
title:  Assembly x86 programming 101 &#58 part 2, drawing a square
author: smbct
date:   2024-05-04 10:00:00 +0200
categories: low-level programming assembly
comments: true
layout: post
---


In the previous post, we've seen how to write a basic hello world program in assembly.
In this post, we will dive further in assembly programming and by writing a more complex program that will illustrate the use of variables and conditionals.
In this new program, we will draw a circle in the terminal with the sys_write system call we used for our "hello world".


## Writing conditionals and loops

An important part of programming languages is the ability to control the execution through conditions.
Conditions appear not only in conditional statements but it also control loops termination.
These programming structures as we know it in languages like C or python can be reproduced in assembly using more rudimentary instruction : jumps and conditional jumps.

#### Jump instructions

Jumps are instructions that allow to move to a specific point in our program.
In our code, this can be simply performed by defining a new symbol and using the `jmp` instruction to this symbol.
Let's start from the hello world written in the previous post:

```nasm
.intel_syntax noprefix
.global _start

_start:

    ; printing hello world
    mov rax, 1
    mov rdi, 1
    lea rsi, [hello_world]
    mov rdx, 14
    syscall

    ; exit
    mov rax, 60
    mov rdi, 0
    syscall

hello_world:
    .asciz "Hello, World!\n"
```

We will now add a new symbol after the "write" system call and jump to this symbol from the beginning of the start function: 

```nasm
_start:

    jmp after_printing

    ; printing hello world
    mov rax, 1
    mov rdi, 1
    lea rsi, [hello_world]
    mov rdx, 14
    syscall

    after_printing:

    ; exit
    mov rax, 60
    mov rdi, 0
    syscall
```

When executing this program you will observe that the "hello world" output is gone.
We have indeed told the program to skip these instructions by directly jumping to the `after_printing` symbol.
Jump can be performed anywhere in the code, including backward and accros functions (we will see in another post that jumping is actually part of a function call).

Jumps becomes more interesting in their conditional form.
To use it, we will use the `cmp` instruction that performs a numerical comparison between two registers/memory spots.
The `cmp` instruction does not directly produce an input but rather sets internal flag that will be read by some following jump instruction.
Starting from the previous code, we will add a conditional jump after comparing two registers :


```nasm
_start:

    mov rax, 43
    mov rbx, 42
    cmp rax, rbx ; compare rax and rbx and set internal flag
    jg after_printing ; jump depending on the internal flag

    ; printing hello world
    mov rax, 1
    mov rdi, 1
    lea rsi, [hello_world]
    mov rdx, 14
    syscall

    after_printing:

    ; exit
    mov rax, 60
    mov rdi, 0
    syscall
```
Here the jg (jump if greater than) instruction will check wether `rax > rbx` from the internal flag set by `cmp`.
Since 43 is greater than 42, our message is not printed to the standard output.
Now if we replace the first line by `mov rax, 42`, the message is being printed as the jump is performed on strict inequality.

#### If..else.. statements

Thanks to jumping instructions we are now able to write conditional statements in our code.
The thinking is a be a bit different from more standard programming but we can setup an "if..else" by placing proper jumps.
Here is an example:

```nasm
    cmp rax, rbx ; compare rax and rbx and set internal flag
    jg else_label

    if_label: ; entering if when "rax <= rbx"

        ; code to perform if condition is not verified
        jmp endif ; skip the "else"
    
    else_label: ; executed when "rax > rbx" is true
    
        ; condition to perform if the code is verified
    
    endif:
```

In this example, we added three different labels to perform an "if..else.." statement.
When the comparison is true, the program will jump directly to the "else" label, making it skip the "if" part.
It is an inverse way of thinking compared to classical statements since the comparison should be false in order to perform the "if" instructions.
At then end of the "if" instructions, a jump is necessary to prevent from executing the "else", hence the presence of an "endif" label.
Note that in this example, the "if_label" is not mandatory as there are no jump to this label, it could be written as a comment.
Additionally, the indentation is not really a convention in assembly but I found it to help clarify the code.

In some situations, writing an if-else statement can be simplified.
This is a question of habits and clarity.

#### Loops

Jumps are not only helpful to write conditional statements but they also offer the possibility to write loops.
Indeed a loop simply consists in a conditional jump verifying if the looping condition is still true or not.
Let's write a simple for loop:

```nasm
    mov rbx, 0

    for_label:

        ; loop instructions

        inc rbx ; increase the loop counter
        
        cmp rbx, 10
        jl for_label ; repeat if the counter is < 10
```

Here we run repeat the loop instructions fot 10 iterations by using the rbx register as our loop index.
The comparison is performed at the end of each iteration, meaning that the program will perform at least one iteration (similarly to a do..while loop).
This behavior may be avoided by adding an additional (unconditional) jump and by performing the comparison before the loop instructions.

The ability to perform control flow in our programs gives us a lot more possibilities. However, for now we relied on registers to store our variables.



## Our second program : drawing a square

Now that we are able to define variables and perform control flow in assembly, our programs become much more interesting.
To demonstrate theses notions, we will write a program that draws a square in the console by using the sys_write system call and by writing "for" loops.
This program will iterate over coordinates of a square of predefined size.

We will first write the base of our program with the exit system call.
We can also define the constants of our program and already add some printing calls that will help us for following. 

```nasm
.global _start, debug
.intel_syntax noprefix

_start:

    ; printing a star
    mov rax, 1
    mov rdi, 1
    lea rsi, [star_character]
    mov rdx, 1
    syscall

    ; printing a new line
    mov rax, 1
    mov rdi, 1
    lea rsi, [star_character]
    mov rdx, 1
    syscall

    ; exit
    mov rax, 60
    mov rdi, 0
    syscall

square_size:
    .quad 20

star_character:
    .word '*'

new_line:
    .word '\n'
```

For this program, it will be convenient to hard-code the size of the square in a word.
I also added the star character '*' and the new line character '\n' as constants since for convenience.
Indeed, the sys_write system call requires an address to the character to be printed and saving them as constants allow to directly give their address in the program's memory.

We may notice that different directives are used when defining the squares_size constant (.quad) and the characters constants (.word).
These directives actually specify the size of these constants (2 bytes for ".word" and 8 bytes for ".quad").
We will discuss more about data sizes in the third part.

#### Drawing a line

Starting by drawing a simple line, we now need to write a "for" loops that will iterate over character positions (or columns).
We will dedicate a register to storing this column index, but we should care about choosing a register that is not being use elsewhere in the program.
Otherwise, its value would be lost.
We can see that rax, rdx, rsi and rdi are already used for the system calls.
We can then dedicate r8 and r9 to store our variables.

To draw a line, we will start from the "for" loop structure that we already implemented earlier in this post.
The loop will surround the star printing instructions: 

```nasm
.global _start, debug
.intel_syntax noprefix

_start:

    ; init the column counter to 0
    mov r8, 0

    for_loop_columns:

        ; printing a star
        mov rax, 1
        mov rdi, 1
        lea rsi, [star_character]
        mov rdx, 1
        syscall

        ; increment the column counter
        inc r8

        ; compare the column counter to the predefined size and jump if required
        cmp r8, [square_size]
        jne for_loop_columns

    ; printing a new line
    mov rax, 1
    mov rdi, 1
    lea rsi, [star_character]
    mov rdx, 1
    syscall

    ; exit
    mov rax, 60
    mov rdi, 0
    syscall

square_size:
    .quad 20

star_character:
    .word '*'

new_line:
    .word '\n'
```

This program does not add any particular complexity to the notions previously seen.
The first action consists in initializing our column index variable `r8` to 0.
Then, we enter the loop by passing the "for_loop_columns" label and print a start character.
Then, the rbx register is incremented (+1) and its value is compared to the square size constant.

#### Drawing a square

Starting from the previous code, printing a square is no more complicated than adding an additional surrounding loop.
This time, we will use the `r9` register to store our row index variable:  

```nasm
.global _start, debug
.intel_syntax noprefix

_start:

    ; init the row counter to 0
    mov r9, 0

    for_loop_rows:
        
        ; init the column counter to 0
        mov r8, 0

        for_loop_columns:
            ; printing a star
            mov rax, 1
            mov rdi, 1
            lea rsi, [star_character]
            mov rdx, 1
            syscall

            inc r8
            cmp r8, [square_size]
            jne for_loop_columns

        ; writing a new line
        mov rax, 1
        mov rdi, 1
        lea rsi, [new_line]
        mov rdx, 1
        syscall
        
        inc r9
        cmp r9, [square_size]
        jne for_loop_rows

    ; exit
    mov rax, 60
    mov rdi, 0
    syscall

square_size:
    .quad 20

star_character:
    .word '*'

space_character:
    .word ' '

new_line:
    .word '\n'
```

Hmmpf that does not exactly look like a square.
In fact, the characters are usually not squares.
We can adjust this without much effort by adding a blank character after each star:

```
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * *
```