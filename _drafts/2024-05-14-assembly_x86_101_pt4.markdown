---
title:  Assembly x86 programming 101 &#58 part 4, printing arrays
author: smbct
date:   2024-05-14 10:00:00 +0200
categories: low-level programming assembly
comments: true
layout: post
---

In the last post of the assembly x86 series, we have seen how to manipulate the stack in order to store local variables.
The stack is also essential for **calling functions** : it is used to store information such as the return instruction address.
In this post, we will see how to write and call functions, and also how to interact with C functions in our program !
These notions will be used to manipulate static arrays : we will copy them and print them using the C printf function.


## More about the stack : pushing and popping values

Before diving into the mechanism of function calls, we should see two instructions related to the stack that have not been mentioned earlier : `push` and `pop`.
The `push` instruction allows to move a value to the stack in an automated way.
This instruction will concretely perform two operations : 

- subtracting the stack address to allocate some bytes in the stack
- moving the value at the resulting address in the stack

`pop` is the reversed instruction : it moves the value from the stack to a register and increases the stack pointer accordingly.
Let's create a simple example :

```nasm
    .global _start, debug, debug2
    .intel_syntax noprefix

    _start:
        mov rbp, rsp

        ; moving the value 42 into 8 bytes in the stack
        sub rsp, 8
        mov [rsp], qword ptr 42

        debug:

        mov rsp, rbp

        ; exit
        mov rax, 60
        mov rdi, 0
        syscall
```

Nothing new in this example, we allocate 8 bytes on the stack and we store the value 42.
We will check that the value is properly stored : run GDB on the program, type `b debug` and `run` to stop just after the move.
After that, execute the commands `print $rbp` and `print $rsp`.
This gives me *0x7fffffffdda0* and *0x7fffffffdd98*.
*98-a0=-8* in hexadecimal, the 8 bits have been allocated (*0x* here simply means hexadecimal).

Now we would check the value, directly from the stack this time : `print *0x7fffffffdd98` (in this step, you should replace the specified address by the output you obtained with the `print $rsp` command).
The star character (\*) here is used to specify an address. 
We end up with the value *42*, perfect!
Note that alternative command `x/dg 0x7fffffffdd98` could also be used to print the value, where *x* stands for "examining" memory.
[This page](https://sourceware.org/gdb/current/onlinedocs/gdb.html/Memory.html#Memory) shows the different options such as the output format and the number of bytes to read.

Now let's modify this code with the push instruction and let's add a pop instruction afterward :

```nasm
    
    _start:
        mov rbp, rsp

        ; moving the value 42 into 8 bytes in the stack
        push qword ptr 42

        debug:

        pop rax

        debug2:

        mov rsp, rbp

        ; exit
        ; ...
```

We can use GDB with the previous commands to check that the `push` instruction did exactly the same as a `sub` followed by a `mov`:

```
(gdb) break debug
(gdb) break debug2
(gdb) print $rbp
$1 = (void *) 0x7fffffffdda0
(gdb) print $rsp
$2 = (void *) 0x7fffffffdd98
(gdb) print *0x7fffffffdd98
$3 = 42
(gdb) print 0x7fffffffdda0-0x7fffffffdd98
$4 = 8
```

Alright, now let's inspect the action of `pop`:

```
(gdb) continue
(gdb) print $rsp
$5 = (void *) 0x7fffffffdda0
(gdb) print $rbp
$6 = (void *) 0x7fffffffdda0
(gdb) print $rax
$7 = 42
```

This is it.
After the `pop` instruction, the `rsp` register is now equal to the `rbp` register, which means the stack pointer took back its value before our allocation.
We can see the second effect of the `pop` instruction : the popped value is now stored in the `rax` register.


## Writing basic functions

We have discovered in a previous post of the series the `jmp` instruction which allows to go to a certain location in the program's code.
You may guess that this is the exact mechanism at the base of function call : a jump is performed to the first instruction of the called function.
However, when the execution of the function is terminated, the program must go back to the instruction that follows this `jmp`.
To do so, we will see that there exists a register dedicated to store the current instruction's address.

#### The Relative Instruction Pointer

The Relative Instruction Pointer `rip` is a register that stores the address of the current instruction to be executed in the program's memory.
This instruction will be useful to navigate in the code when calling functions.
To see how it works, let's start from the simple "hello world" program :

```nasm
_start:

    mov rax, 1
    mov rdi, 1
    lea rsi, [hello_world]
    mov rdx, 14
    syscall

    ; exit
    mov rax, 60
    mov rdi, 0
    syscall

hello_world:
    .asciz "Hello, World!\n"
```

Let's run GDB on this program once again and, this time, execute only the first instruction with : `starti`.
We can then print the value of the `rip` register : `print $rip`.

#### Writing and calling our first functions

With our present knowledge, we are actually already capable of writing functions.
To do so, we can use a `jump` instruction that will move us in the code toward


## Calling C functions

#### Calling printf

## Being called by C functions



