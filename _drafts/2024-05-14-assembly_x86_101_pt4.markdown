---
title:  Assembly x86 programming 101 &#58 part 4, printing arrays
author: smbct
date:   2024-05-14 10:00:00 +0200
categories: low-level programming assembly
comments: true
layout: post
---

In the last post of the assembly x86 series, we have seen how to manipulate the stack in order to store local variables.
The stack is also essential for **calling functions** : it is used to store information such as the return instruction address.
In this post, we will see how to write and call functions, and also how to interact with C functions in our program !
These notions will be used to manipulate static arrays : we will copy them and print them using the C printf function.


## More about the stack : pushing and popping values

Before diving into the mechanism of function calls, we should see two instructions related to the stack that have not been mentioned earlier : `push` and `pop`.
The `push` instruction allows to move a value to the stack in an automated way.
This instruction will concretely perform two operations : 

- subtracting the stack address to allocate some bytes in the stack
- moving the value at the resulting address in the stack

`pop` is the reversed instruction : it moves the value from the stack to a register and increases the stack pointer accordingly.
Let's create a simple example :

```nasm
    .global _start, debug, debug2
    .intel_syntax noprefix

    _start:
        mov rbp, rsp

        ; moving the value 42 into 8 bytes in the stack
        sub rsp, 8
        mov [rsp], qword ptr 42

        debug:

        mov rsp, rbp

        ; exit
        mov rax, 60
        mov rdi, 0
        syscall
```

Nothing new here, we allocate 8 bytes on the stack and we store the value 42.
We will check that the value is properly stored : run GDB on the program, type `b debug` and `run` to stop just after the move.
After that, execute the commands `print $rbp` and `print $rsp`.
This gives me *0x7fffffffdda0* and *0x7fffffffdd98*.
*98-a0=-8* in hexadecimal, the 8 bits have been allocated (*0x* here simply means hexadecimal).

Now we would check the value, directly from the stack this time : `print *0x7fffffffdd98` (in this step, you should replace the specified address by the output you obtained with the `print $rsp` command).
The star character (\*) here is used to specify an address. 
We end up with the value *42*, perfect!
Note that alternative command `x/dg 0x7fffffffdd98` could also be used to print the value, where *x* stands for "examining" memory.
[This page](https://sourceware.org/gdb/current/onlinedocs/gdb.html/Memory.html#Memory) shows the different options such as the output format and the number of bytes to read.

Now let's modify this code with the push instruction and let's add a pop instruction afterward :

```nasm
    
    _start:
        mov rbp, rsp

        ; moving the value 42 into 8 bytes in the stack
        push qword ptr 42

        debug:

        pop rax

        debug2:

        mov rsp, rbp

        ; exit
        ; ...
```

We can use GDB with the previous commands to check that the `push` instruction did exactly the same as a `sub` followed by a `mov`:

```
(gdb) break debug
(gdb) break debug2
(gdb) print $rbp
$1 = (void *) 0x7fffffffdda0
(gdb) print $rsp
$2 = (void *) 0x7fffffffdd98
(gdb) print *0x7fffffffdd98
$3 = 42
(gdb) print 0x7fffffffdda0-0x7fffffffdd98
$4 = 8
```

Alright, that is indeed an 8 bytes allocation followed by the value 42 being stored in the stack.
Now let's inspect the action of `pop`:

```
(gdb) continue
(gdb) print $rsp
$5 = (void *) 0x7fffffffdda0
(gdb) print $rbp
$6 = (void *) 0x7fffffffdda0
(gdb) print $rax
$7 = 42
```

This is it.
After the `pop` instruction, the `rsp` register is now equal to the `rbp` register, which means the stack pointer took back its value before our allocation.
We can see the second effect of the `pop` instruction : the popped value is now stored in the `rax` register.

#### Preserving the stack pointers across function calls



## Writing basic functions

We have discovered in a previous post of the series the `jmp` instruction which allows to go to a certain location in the program's code.
You may guess that this is the same mechanism at the base of function call : a jump is performed to the first instruction of the called function.
However, when the execution of the function is terminated, the program must go back to the instruction that follows this `jmp`.
To do so, we will see the `call` and `ret` instructions that take care of this.

#### Writing and calling our first function

Let's start with a simple function that prints "hello world" :

```nasm
.global _start, _before_call, _after_call
.intel_syntax noprefix

_print_hello_world:
    mov rax, 1
    mov rdi, 1
    lea rsi, [hello_world]
    mov rdx, 14
    syscall
    ret

_start:

    _before_call:
    call _print_hello_world
    _after_call:

    ; exit
    mov rax, 60
    mov rdi, 69
    syscall

hello_world:
    .asciz "Hello, World!\n"

```

Compared to our hello_world example, this code simply encapsulates the printing instructions within a function by the use of a new symbol ("_print_hello_world").
The function is executed with the `call` instruction and the program returns the the `_start` function execution thanks to the `ret` instruction.
We will use the two additional symbols "_before_call" and "_after_call" as debugging labels with gdb to see how it works.

Calling functions brings a new dimension in our code : we are now manipulating the program's instructions addresses at runtime.
Indeed, when a function is being executed, the program must remember the address of the instruction that calls the function (in the program's memory, where all instructions are loaded).
By doing so, at the return instruction the programs knows where to "return" in the program's memory.
There exists a register that is dedicated to store the address of the next instruction to be executed : the `rip` register (Relative Instruction Pointer).
We will use look at this register to understand our program.

#### How function calls work

Let's use gdb on the previous code to see what is happening.
We add breakpoints at `_before_call`, `_print_hello_world` (just after the `call` instruction) and at `_after_call` to see how the stack is manipulated.
After executing the `run` command in gdb, the program will start and pause at `_before_call`, just before the function call.
To illustrate the `rip` register mentioned before, we can already print the pointed instruction with :

```
(gdb) x/i $rip
=> 0x401020 <_start>:	call   0x401000 <_print_hello_world>
```

We can see the address, *0x401020* and the encoded instruction which is our `call`.
Let's also print our stack pointer address : `print $rsp`, which gives *0x7fffffffdda0* in my case.
Then, the `continue` command makes the program stops at `_print_hello_world`.
We will see what changed on the stack :

```
Breakpoint 3, 0x0000000000401000 in _print_hello_world ()
(gdb) print $rsp
$3 = (void *) 0x7fffffffdd98
(gdb) x *0x7fffffffdd98
   0x401025 <_after_call>:	mov    $0x3c,%rax
(gdb) print 0x7fffffffdd98-0x7fffffffdda0
$4 = -8
```

We can see that the `rsp` register has changed from *0x7fffffffdda0* to *0x7fffffffdd98*.
8 Bytes have been allocated : the program has stored the return address of the function call.
Indeed, by printing the instruction at the corresponding location, we see that it corresponds to the instruction that follows the `call` one in the `_start` function : `mov $0x3c,%rax` (*0x3c* corresponds to the value 60 in decimal).

We continue the execution to see what happens when returning from the function :
```
Continuing.
Hello, World!

Breakpoint 2, 0x0000000000401025 in _after_call ()
(gdb) print $rsp
$5 = (void *) 0x7fffffffdda0
(gdb) x/i $rip
=> 0x401025 <_after_call>:	mov    $0x3c,%rax
```
The `continue` command in gdb now brings us at the `_after_call` label.
We can see that the `rsp` register took back its value from before the call, the return address was is no longer necessary and is popped out with the `ret` instruction.
We additionally print the value of the `rip` register : the value is the same as the one previously stored on the stack.

#### Passing parameters

For now, we have seen how to write a simple functions that takes no parameters and does return nothing.
In practice, parameters and return values are essential to our programs.
There are actually different ways to pass information between the functions : you may pass parameters into registers for instance or store them into the stack.
We will see more about parameters and return value in the next part of this post but for the moment, I propose the following exercise : modify the previous program to pass to the function an integer indicating the number of time the "hello world" string should be printed.
Such parameter would be passed through the stack.
I will add a link to the solution at the end of the post.



## Calling the C printf functions

One dimension that function calls bring to our program is not only the ability to structure it, but also the opportunity to call higher level libraries that would perform more advanced operations like opening windows, networking, etc..
However, although we previously had the freedom to decide our own convention for parameters and return value, calling a function from a library requires us to follow the library's convention.
We will see how to do so by calling the "printf" function from the standard C library. 

#### Using the C standard lib in our program

Our program's compilation will now change a bit.
Previously, we created executables from assembly code by using nothing more than systems calls to interact with a user.
Now, the idea is to interface the program with the C standard library.

Adding the C standard library to our program's is simply done by removing the option `-nostdlib` when linking the executable with gcc.
However, the C library adds a lot more features to our program : it defines the _start function (program's entry point) by itself.
For this reason, our program's first function will now be the classical `main` function.
The "hello world" code now becomes :

```nasm
.global main
.intel_syntax noprefix

main:

    push rbp
    mov rbp, rsp

    mov rax, 1
    mov rdi, 1
    lea rsi, [hello_world]
    mov rdx, 14
    syscall

    mov rsp, rbp
    pop rbp

    ; return
    mov rax, 42
    
    ret

hello_world:
    .asciz "Hello, World!\n"
```

There are two changes regarding the previous hello_world : our function is now called main and it will be automatically be called by the `_start` function defined in the cstdlib ; and since it is now a called function, the `ret` instruction is now called at its end.
The compilation is done as previously, except for the second command that now becomes `gcc -static my_program.o -o my_program`.

You can verify that the program's output is actually *42*, which is given as the main's return value : `./my_program ; echo $?`.
Now if you try to compile our first hello_world program with this same command, so that it is linked with the c standard library, this would not work since the program's entry point `_start` would be defined twice : once in the code and another time in the library.
If you want a more precise idea of the additional material added by the standard libc, you might check this [interesting article](http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html)!

#### Passing parameters to printf

Now that everything is in place, let's call the printf function.
Know that since the standard libc is now linked, the `printf` symbol will be known by the linker.
Now the important thing is to see how to pass parameters to the "printf" functions.
That part is tricky : the (calling) convention used by Linux is called the **AMD64 System V ABI**.

Documentation is sometimes hard to find and I personally learned this from this [stackoverflow post](https://stackoverflow.com/questions/38335212/calling-printf-in-x86-64-using-gnu-assembler).
You can see in the post that parameters are in part passed by registers : `rdi` for the first one, `rsi` for the second one, `rdx` for the third etc.. 
They also indicate that the `al` (the 8 bits version of `rax` register) register must be set to 0 since "printf" has a variable number of arguments.

Following the convention, our printf call to print "hello world" now becomes :

```nasm
    xor eax, eax ; al is set to 0
    lea rdi, [hello_world] ; 1st argument passed to register
    call printf
```

If you try this, you would normally see a segmentation fault :(

#### One more requirement : stack pointer alignment

By further reading the stackoverflow post that I linked above, we learn that there is on more condition that needs to be met when calling functions in the **AMD64 System V ABI** convention : the stack pointer must be aligned to 16 bytes, meaning its value must be a multiple of 16.

You can run gdb on your program and check the value of `rsp` before calling "printf" : `breakpoint main` followed by `print $rsp`.
It gives *0x7fffffffdbd8* for me and *0x7fffffffdbd8 modulo 0x10 = 0x8* (where *0x10* is 16 in hexadecimal).
We see that there is an 8 bytes shift of the `rsp` value.
This shift comes from the fact that the `call` instruction pushes the return address (8 bytes) to the stack, as we saw previously.
As a result the stack pointer is misaligned by 8 bytes.
This will be fixes by simply re-aligning the stack pointer before starting the call, which can be done by "allocating" 8 additional bytes (unused) :

```nasm
    sub rsp, 8
    xor eax, eax ; al is set to 0
    lea rdi, [hello_world] ; 1st argument passed to register
    call printf
    add rsp, 8
```

This should now work as expected!
Note that since our string is zero terminated (it ends by '\0', as defined by the .asci**z** type with the gnu assembler), it is not necessary to specify its length to printf. 

In our following codes, we will now make sure the stack pointer is well aligned before starting any operation in our functions.
A proper place to do it is when the local variables are allocated, as we saw in the previous post of the series.
This may also be done automatically by subtracting the offset : `rsp` modulo 8, which can be performed by "anding" 15 to the value of `rsp`: `and rsp, 15` (recall that a modulo operation on a power of two can be obtained by directly looking at the right number of bits in the binary representation).

#### Printing integers with printf

Calling a C function was not easy!
The good thing is now it will be much easier to bring concrete features to our programs.
Let's start by accomplishing a task that was previously much harder : printing integer values.

To print a value in the terminal, we can use the printf function with its formatting ability : the value would be passed as a parameter, as well as a string indicating how to format it.
We can have a look at the [documentation](https://cplusplus.com/reference/cstdio/printf/) of "printf" to choose the correct formatter.
We start by defining the formatter as a constant string in our program (this does not change) :

```nasm
integer_formatter:
    .asciz "integer value: %i\n"
```

The  "%i" formatter is used in order to print a decimal integer.
We will then call printf and pass this string as well as the register value.
For this, we will use the `rsi` register, as it is specified to pass the second argument in Linux.

```nasm
    xor eax, eax
    lea rdi, [integer_formatter]
    mov rsi, 42
    call printf
```

The program should now print: "integer value: 42".
This adds a lot more possibilities to interact with the user!

#### Preserving registers across function calls



## Printing an array

Now that we know how to call printf, we will perform a useful task for the future post : printing an array!
We will start by defining a constant array in the program's memory :

```nasm
my_array:
    .byte 5, 12, 42, 8, 1, 3, 7, 25, 14
my_array_length:
    .word 9
```

In this case, the array elements will be stored as bytes (8 bits long, integer values between -128 and 127).
We also define a constant for its size as a word (2 bytes).
That will eventually be helpful.

Now we may define our strings constants to be used by printf :

```nasm
array_elt_formatter:
    .asciz "%hhd "
new_line:
    .asciz "\n"
my_array_str:
    .asciz "My array : "
```

The "array_elt_formatter" is used to format a single byte as an integer with printf, followed by a space.
We also define the new_line string that only prints the return character for convenience, as well as a string announcing the array to be printed.

#### The local variables

We will need 2 local variables in our code : an 8 bytes variable to store the array address and a 2 bytes variable to an index for iterating over the array.
This results in 10 bytes allocated on the stack.
With the 8 bytes already present to store the return address of the main function, the stack pointer would be aligned to 26 bytes.
Hence, 6 additional bytes are necessary for a 16 bytes alignment (*32=2x16*). 

```nasm
; storing the rsp value before local variables definition
mov rbp, rsp
; rbp - 8 : array pointer, 8 bytes
; rbp - 10 : array index, 2 bytes
; 6 padding bytes
sub rsp, 24
```
The local variables are then initialized, and the first string announcing the array can be printed :

```nasm
mov [rbp-10], word ptr 0 ; array_index <- 0
; loading the array pointer
lea rax, my_array
mov [rbp-8], rax

; printing the "my_array_str" string
xor eax, eax
lea rdi, [my_array_str]
call printf
```

#### Writing the main loop

The main scheme here is similar to our print_square and print_circle programs.
What changes is the call to printf and the array manipulation in order to extract its values.
Accessing the values of the array is performed by increasing the array address.
Indeed, the address accessed through the label "my_array" actually points toward the first value of the array in the program's memory.
Since are the values are contiguous, and since they are coded on 1 byte, accessing the next value is performed by increasing the address by one (recall that the addresses are expressed as bytes).

Our main loop is as follows :

```nasm
for_loop_writing:
    ; printing the "my_array_str" string
    xor eax, eax
    lea rdi, [array_elt_formatter]
    mov rsi, [rbp-8] ; load the array pointer
    mov sil, [rsi] ; load the value stored at the address
    call printf

    inc byte ptr [rbp-8] ; increase the array pointer
    inc word ptr [rbp-10] ; increase the array index
    mov al, [rbp-10]
    cmp al, [my_array_length]
    jne for_loop_writing ; test if all characters have been printed
```

You may notice that two steps are necessary to load a value from the array before calling printf : the address of the array must first be retrieved from the stack and then, the `mov` instruction is used to load the value coded at the address.
Note that the 1-byte register `sil` is used here to store the array values since the array values are encoded on single bytes.
These two steps cannot be concatenated into a sigle one since an instruction can have a memory reference in only one of its operand.

After the call to printf, the array index is increased as well as the array address.
Note the different prefixes as these two values are not coded on the same number of bytes.
Then, the index is compared to the array size, which is performed on two steps for the reasons evoked just before.

This is it for printing the array !
The next step for this code would be to encapsulate it as a function.
This time, we may use the "Linux calling convention" to pass the parameters : for instance using `rdi` and `si` (`rsi`) to pass the array pointer and the array length respectively.
I will leave it as an exercise and put the solution in the repository.

## What's next ?


