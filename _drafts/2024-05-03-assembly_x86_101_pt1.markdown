---
title:  Assembly x86 programming 101 &#58 part 1, Hello, world!
author: smbct
date:   2024-05-03 10:00:00 +0200
categories: low-level programming assembly
comments: true
layout: post
---

The last few months, I gained an increasing interest in low level programming and especially in assembly programming.
What seemed for a long time an obscure and unpractical hobby to me has become a very interesting topic as I started practicing.
From the point of view of someone with a background in computer of science, learning assembly programming feels like digging into the fundamentals of computing and looking back at the history of modern computers.
Learning to code in assembly would be a way to get a better understanding of how computers and programs work and how to secure and optimize them.

In this blog post, I would like to make an introduction to basic programming in assembly.
I plan to make 3 different posts to cover the basics as well as practical development with higher level libraries.
My goal is to make you feel like it is actually possible to develop modern applications in assembly, although this would be much slower and les convient than using any modern language.
However, let's make small disclaimer : I learned theses notions very recently and on my own.
I will probably make some imprecisions and mistakes along the way.
My goal is mainly to give a taste of low level coding by making concrete programs and apps.
I will use linux tools in theses posts but this could probably be adapted to any other operating system. 

Parler du jeu human ressource machine
Lien vers les vid√©os low level learning

## Programming with... Assembly?

Assembly may be a famous word in the wold of computing, it is still worth researching a little about this term.
From the [wikipedia](https://en.wikipedia.org/wiki/Assembly_language) page, we learn that assembly actually refers to any low level programming language (meaning close to the computer hardware) that has  very similar instructions than the processor's actual instructions.

#### Architecture specific programming

This means that an assembly language is associated to a specific computer architecture such as x86 (usually found in desktop computers) and ARM (processors found in smartphones and other mobile devices).
A program made with an x86 assembly language will be then unable to run on ARM computer devices for instance.
In this series, we will only look at **x86-64 assembly**, x86-64 being the usual architecture of 64 bits processors of modern personal computers.
However, keep in mind that it is usually possible to practice assembly programming for other platforms on a personal computer by using an emulator.
It would be also interesting to look at other architectures such as ARM that became recently more popular in the word of personal computers with the [apple silicons](https://en.wikipedia.org/wiki/Apple_silicon).
ARM is also present in Raspberry Pi boards and Nintendo switch consoles.
MIPS is another interesting architecture as multiple old generation consoles such as the nintendo 64 and playstation relying on it.




#### Compilation of assembly programs?

When it comes to programming languages, one may often distinguish compiled langages such as C, C++, Rust, etc..  from interpreted languages like python.
In programming, compilation may be described as the process of translating a program into machine code.
The machine code in question is actually one of our architecture's specific assembly language mentioned earlier.

This means that while assembly code is not *compiled* into machine code, the readable assembly code that one would wrote is still to be translated into a binary form in order to become executable by the system.
This step is performed by the *assembler*, a program that produces actual object code by following a given file format such as the [elf format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) on linux systems.

Machine code in object code then corresponds to the (almost ?) un-readable binary form of a program that can be directly executed by the operating system.
However, a readable form of machine code can be used to directly look at this machine code : this is what we usually call assembly language (and assembly programming).
This means that any compiled program that has been written in C language can be turned into readable assembly code (or readable machine instructions).
Of course, it is impossible to recover an original interpretable code with variable names, comments etc... from any compiled program.
Nonetheless, looking at assembly code from a binary program can be useful for malware analysis for instance.

An important note to me is that while assembly really feels like giving precise orders to our computers and making it execute exactly our program's instruction, modern processors are extremely complex and many hidden operations are still happening under the hood, avoiding us to fully apprehend it.
I think that assembly is still worth learning is it helps to better understand computers.


## A first assembly program

We will start by writing a simple program that performs basic operations.
Our tools here will be any text editor supporting x86 assembly syntax, an assembler of x86 assembly code.
Visual Studio can be used with the "x86 and x86_64 Assembly" extension for the writing part.
To produce the executable we will us the gnu assembler, which is the assembler used by gcc.
GCC will also be used to link our program and produce the executable file (GCC will actually call "ld" for linking).
Last, but not least, we will also exploit the GNU debugger (GDB) to inspect our program.

Let's write our first lines of assembly code :

```nasm
.intel_syntax noprefix
.global _start

_start:

    ; do nothing

```

The first line of the code does nothing more than specifying the use of the intel syntax with some noprefix mode, a syntax that is more readable for beginners.
The second line make sure that the symbol _start will be visible from outside the program.
In general, symbols such as local function names would not be exported when releasing programs as they are not necessary from the outside.
On the contrary, function names that are part of a library's interface would be exported so that a user would use it to interface his own code.
In our case, "_start" is the name of our program's entry point (first line to be executed) and this symbol must be known from the outside.

Then the definition of our *function* `_start` begins with its label followed by a colon (:).
For now there are no instructions to be performed.

#### Compilation and linking

I will use the term *compilation* to designate the process of making an executable file from the assembly code even though this term is more adapted to languages such as C.
To compile this peace of code, we will first execute the `as` command that produces an object file :

`as hello_world.s -o hello_world.o`

You may recognize the '.o' extension that is also used as temporary compiled files when compiling C language.
You may run command `file hello_world.o` on the output to verify that the produced file is an executable file on the "elf" format.

Now we can use the GCC to produce an actual executable :

`gcc hello_world.o -o hello_world -static -nostdlib`

Two important options are passed to gcc : `-static` to produce a position-dependant executable and `-nostdlib` which prevent from using the C standard library in our program.
These two options are required for now but we will see in another post how to do differently.

When we try to execute this program it results into a *segmentation fault*.
The reason why is that the program does not actually know how to exit.
We will add the following lines to solve the issue :

```nasm

_start:

    ; exiting
    mov rax, 60
    mov rdi, 42
    syscall

```

This program now becomes much more interesting!
What is performed is call a "system call", performed by the last instruction
[System calls](https://www.geeksforgeeks.org/introduction-of-system-call/) are a way for programs to interact with the operating system. 
The two instructions preceding the call are used to set the values of two two registers `rax` and `rdi`.
The first line specify the type of system call to perform, which is sys_exit with 60 here ([tables](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/) of linux system calls can be found online).
The second line set the return value of the program, similarly to ``return 42;`` at the end of a C program.

After compiling the program again the execution does not produce a segmentation fault anymore!
This time we can run it and check its return value in bash :
```./hello_world ; echo $?``` which outputs 42!


#### Registers

We have just seen in our previous code the use of registers to pass parameters to the system call.
Registers are central in assembly programming.
There are ultra fast memory spots in the processor that would be used as **temporary** variables to perform the program's operations.
This means that these variables (which aren't really variables in fact) will not serve as storing our data, and the same registers will be used successively to hold unrelated data.
There are a limited number of registers in the x86-64 architecture and all registers have a name and a more or less specified use.
A list of registers may be found [online](https://wiki.osdev.org/CPU_Registers_x86-64). 

It is important to note that registers may have different sizes, which will be expressed in bits or bytes (recall that 1 byte equals 8 bits).
In the x86-64 architecture, registers can be up to 64 bits (8 bytes).
The size of registers may depend on their use and some of the registers can be used in different size (by varying their name).
As previously, tables can be found online with [registers sizes](https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture).


#### Hello world in assembly

Starting from the previous code, we can now make a program that writes the famous "hello world" in the terminal.
To do so, we will use the `sys_write` system call.
You may see the previous link [on linux system calls](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/) that to invoke a "sys_write" system call that prints a string, the `rax` register must be set to `1`.
The `rdi` register will specify the file descriptor, and it will be set to `1` to write the the standard output.
There are two other parameters: `rsi` will be the address of tha memory containing our "hello world" string and "rdx" will be the length of this string.
We can define the string as a constant in our program by defining a new symbol :

```nasm
hello_world:
    .asciz "Hello, World!\n"
```

By doing so, the string will be hard coded into the executable and the label `hello_world` will allow us to directly refer to it (more especially to its address) in our code.
We can now complete our code to produce the output :


```nasm
.intel_syntax noprefix
.global _start

_start:

    ; printing hello world
    mov rax, 1
    mov rdi, 1
    lea rsi, [hello_world]
    mov rdx, 14
    syscall

    ; exit
    mov rax, 60
    mov rdi, 69
    syscall

hello_world:
    .asciz "Hello, World!\n"
```

#### Inspecting our program with gdb

It might strike us that in assembly an operation as fundamental as writing to the standard output already takes several lines of code.
This make us realize that in higher level programming languages many tasks are performed in background as develop.
In C, printing the value of a variable would be as easy as only one call to the "printf" function and passing the variable to it.
Here, a sys_write would only handle a string and no function is predefined to transform a integer value into a string of characters.

Instead of coding our own functions, which could be a good exercise though, we can run the gnu debugger to inspect our program.
Let's add few lines of code at the beginning of our function:

```nasm
_start:

    mov rax, 30
    add rax, 12
    debug:
```

You may guess that the first new line loads the value 30 to the rax register and the second one adds 12 to it.
We will verify this behavior with gdb by adding a *breakpoint*, which is the reason why our program has a new label "debug".
This will make the program stop just after the two new instructions and allow us to inspect the registers.
To do so, we can add our new symbol to the list of global symbols, which becomes : `.global _start, debug`.
Then, we compile the program and run gdb by attaching the program to it : `gdb hello_world`.
Then we can add the breakpoint by referring the the new "debug" label : `b debug`.
We now execute the program from the beginning : `start`.
Normally, the program would stop after executing the instruction preceding out label, indicating "Breakpoint 1".
From this point, we can verify the register's value : `print $rax` which produces the intended output "$1 = 42".
We can also obtain information about all registers with the command `info registers`. 

I find the use of in-code labels very convenient for debugging.
For instance you may define several debugging symbols like `.global _start, debug1, debug2, ...` and set breakpoints to them in gdb such that the program execution will stop successively at these different points in the program.
This feels even more convenient than specifying a line number as one would do when debugging a C program, even though this is also possible with our program.
bdb will be of great use in the following as we practice assembly so it is worth noting its capabilities.

