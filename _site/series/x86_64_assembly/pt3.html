<!DOCTYPE html>
<html lang="en">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  

  <title>
    
      Assembly x86-64 programming 101 &#58 chapter 3, drawing a circle &middot; smbct's blog
    
  </title>

  <!-- 
 -->

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="series_article">

    
    <div id="sidebar">
  <header>
    <div class="site-title">
      <a href="/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        smbct's blog
      </a>
    </div>
    <p class="lead">Notes on computer science, programming, society and more.</p>
  </header>
  <nav id="sidebar-nav-links">

  
    
      <a class="home-link "
          href="/">Blog</a>
    
  
  
  

  

  


  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  



  <!-- should be improved -->
  
  <a class="category-link "
          href="/pages/series.html">Series </a>
  

  


  
    
  

  
    
      <a class="category-link "
          href="/pages/about.html">About</a>
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">

  
    <a id="github-link"
       class="icon" title="Github Profile" aria-label="Github Profile"
       href="https://github.com/smbct">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 28" height="24" width="28"><path d="M12 2c6.625 0 12 5.375 12 12 0 5.297-3.437 9.797-8.203 11.391-0.609 0.109-0.828-0.266-0.828-0.578 0-0.391 0.016-1.687 0.016-3.297 0-1.125-0.375-1.844-0.812-2.219 2.672-0.297 5.484-1.313 5.484-5.922 0-1.313-0.469-2.375-1.234-3.219 0.125-0.313 0.531-1.531-0.125-3.187-1-0.313-3.297 1.234-3.297 1.234-0.953-0.266-1.984-0.406-3-0.406s-2.047 0.141-3 0.406c0 0-2.297-1.547-3.297-1.234-0.656 1.656-0.25 2.875-0.125 3.187-0.766 0.844-1.234 1.906-1.234 3.219 0 4.594 2.797 5.625 5.469 5.922-0.344 0.313-0.656 0.844-0.766 1.609-0.688 0.313-2.438 0.844-3.484-1-0.656-1.141-1.844-1.234-1.844-1.234-1.172-0.016-0.078 0.734-0.078 0.734 0.781 0.359 1.328 1.75 1.328 1.75 0.703 2.141 4.047 1.422 4.047 1.422 0 1 0.016 1.937 0.016 2.234 0 0.313-0.219 0.688-0.828 0.578-4.766-1.594-8.203-6.094-8.203-11.391 0-6.625 5.375-12 12-12zM4.547 19.234c0.031-0.063-0.016-0.141-0.109-0.187-0.094-0.031-0.172-0.016-0.203 0.031-0.031 0.063 0.016 0.141 0.109 0.187 0.078 0.047 0.172 0.031 0.203-0.031zM5.031 19.766c0.063-0.047 0.047-0.156-0.031-0.25-0.078-0.078-0.187-0.109-0.25-0.047-0.063 0.047-0.047 0.156 0.031 0.25 0.078 0.078 0.187 0.109 0.25 0.047zM5.5 20.469c0.078-0.063 0.078-0.187 0-0.297-0.063-0.109-0.187-0.156-0.266-0.094-0.078 0.047-0.078 0.172 0 0.281s0.203 0.156 0.266 0.109zM6.156 21.125c0.063-0.063 0.031-0.203-0.063-0.297-0.109-0.109-0.25-0.125-0.313-0.047-0.078 0.063-0.047 0.203 0.063 0.297 0.109 0.109 0.25 0.125 0.313 0.047zM7.047 21.516c0.031-0.094-0.063-0.203-0.203-0.25-0.125-0.031-0.266 0.016-0.297 0.109s0.063 0.203 0.203 0.234c0.125 0.047 0.266 0 0.297-0.094zM8.031 21.594c0-0.109-0.125-0.187-0.266-0.172-0.141 0-0.25 0.078-0.25 0.172 0 0.109 0.109 0.187 0.266 0.172 0.141 0 0.25-0.078 0.25-0.172zM8.937 21.438c-0.016-0.094-0.141-0.156-0.281-0.141-0.141 0.031-0.234 0.125-0.219 0.234 0.016 0.094 0.141 0.156 0.281 0.125s0.234-0.125 0.219-0.219z"></path>
</svg>

    </a>
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  

  <!-- Optional additional links to insert for icons links -->




<!-- index pages are treated separately to handle pagination -->


<!-- for other pages, the link to the translated page is in a file -->


<!-- When one of the link is not set, the corresponding flag cannot be clicked -->

<a id="icon_flag"
     class="icon_flag active"
     
     >
üá¨üáß <div></div>
</a>
<a id="icon_flag"
  class="icon_flag"
  
>
üá´üá∑ <div></div>
</a>



</nav>

  <p>
  &copy; 2024.
  <a href="/LICENSE.md">MIT License.</a>
</p>

</div>
    

    <main class="container">
      <header>
  


<p class="back-link">
    <a href="/series/x86_64_assembly/headline.html"><span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>Assembly x86-64 programming 101</a>
</p>


  <h1 class="post-title">Assembly x86-64 programming 101 &#58 chapter 3, drawing a circle</h1>
</header>
<div class="content">
  <div class="post-meta">
  
  <!-- Thanks to https://stackoverflow.com/questions/10714980/locale-specific-date-in-jekyll -->
  <span class="post-date">
    üìÖ
    
      09 May 2024
    
  </span>

  ‚Ä¢ ‚è≤Ô∏è
  <!-- taken from https://carlosbecker.com/posts/jekyll-reading-time-without-plugins/ -->

<span class="reading-time" title="Estimated read time">
  
  
    19 
    
      mins
    
  
</span>
  ‚Ä¢
  
  üá¨üáß
  

  <span class="post-categories">
    
      &bull;

      
      
      

      
        low-level programming assembly
      
    
  </span>
</div>



  <div class="post-body">
    <p>We‚Äôve previously seen how to code a ‚Äúhello world‚Äù program in assembly and how to perform conditions and loops.
In our previous program that draws a square, we used registers to store our variables.
Unfortunately, registers are not meant to store data and should rather be used as an intermediate memory location to perform the processor‚Äôs instructions.
To ‚Äúdefine‚Äù variables in assembly, we instead need to directly allocate memory to our program.
Our goal in this post we will be to start from our square drawing program and modify it in order to draw a circle.
More importantly, we will see how to properly store our variables in <strong>the stack</strong> ü•û instead of using registers.</p>

<h2 id="defining-local-variables-on-the-stack">Defining local variables on the stack</h2>

<p>Programming languages usually rely on two different modes for storing variables : <a href="https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation/?ref=header_search">the stack and the heap</a>.
You may have heard of them if you are familiar with lower level languages such as C or C++.
The heap is dedicated to dynamic allocations : it is used when the size of the data to be allocated is only known during the program‚Äôs execution (at runtime).
On the other hand, the stack is used to store local variables and internal information about function calls.</p>

<p>We will use the stack here to store our program‚Äôs variables.
It is the simplest way to perform memory allocation since it does not require any system or function call.
Its use is similar to a stack of plates, with a last-in-first-out management : memory is always allocated on its top and the last allocated memory would be de-allocated first.
The top of the stack can be accessed via its memory address stored in the <code class="language-plaintext highlighter-rouge">rsp</code> register (‚Äúsp‚Äù standing for ‚Äústack pointer‚Äù).
Our memory allocation will be performed by manually manipulating this address.</p>

<h4 id="manipulating-the-stack-pointer-to-allocate-memory">Manipulating the stack pointer to allocate memory</h4>

<p>The stack pointer address stored in the <code class="language-plaintext highlighter-rouge">rsp</code> registers is expressed in bytes, meaning that it points to a 8-bits memory space (recall that the <a href="https://en.wikipedia.org/wiki/Byte">byte</a> is the smallest unit of storage and 1 byte equals to 8 bits).
The stack in x86 assembly grows <strong>downward</strong>, meaning that the address stored in <code class="language-plaintext highlighter-rouge">rsp</code> will actually decrease as memory is allocated.</p>

<p>In the following example, 4 bytes of memory are allocated on the stack by subtracting the value 4 to the stack address (addresses being expressed in bytes):</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">_start</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="nl">_start:</span>

    <span class="c1">; allocating 4 bytes in the stack</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">4</span>

    <span class="c1">; storing the value 42 to the reserved space</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rsp</span><span class="p">],</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="mi">42</span>

    <span class="c1">; inspecting the value through a register</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsp</span><span class="p">]</span>

    <span class="c1">; memory is de-allocated by restoring the original rsp value</span>
    <span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">4</span>

    <span class="c1">; exit</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">60</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">syscall</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Let‚Äôs compile and analyse the code with GDB, as we did in the first chapter of the assembly series.
We will start by compiling the code in debug mode (-g option) and by adding breakpoints at three different places in the code: <code class="language-plaintext highlighter-rouge">b code.s:5</code> (before the allocation), <code class="language-plaintext highlighter-rouge">b code.s:8</code> (after the allocation) and <code class="language-plaintext highlighter-rouge">b code.s:14</code> (after writing in the stack).
Here ‚Äúcode.s‚Äù corresponds to the name of our assembly file.</p>

<p>Now let‚Äôs start the program in GDB until the first breakpoint and print the initial stack‚Äôs top address : <code class="language-plaintext highlighter-rouge">print $rsp</code>.
This outputs <em>0x7fffffffddb0</em> in hexadecimal in my terminal.
This address points toward the last byte that has been reserved before we started our function.
Thus memory at this address should not be used by our code.</p>

<p>Then the 4 bytes (32 bits) of memory are allocated by subtracting 4 to the current stack top address.
After this operation, the <code class="language-plaintext highlighter-rouge">rsp</code> register points toward the start of our 4 bytes memory location that is, this time, reserved for our own use. 
We can use the command <code class="language-plaintext highlighter-rouge">continue</code> in GDB to go to the next breakpoint after the allocation and check the new value of <code class="language-plaintext highlighter-rouge">rsp</code>:
This gives me <em>0x7fffffffddac</em>.
Checking the difference in an hexadecimal calculator : <em>0x7fffffffddac-0x7fffffffddb0 = -4</em>, we have reserved our 4 bytes  of memory in the stack!</p>

<p>We can let the program continue again so that the value 42 is stored in the stack at the reserved location in the with the <code class="language-plaintext highlighter-rouge">mov</code> instruction.
As opposed to previously, we use the brackets here to indicate that the value 42 should not be stored in the <code class="language-plaintext highlighter-rouge">rsp</code> register but rather at the memory address stored in <code class="language-plaintext highlighter-rouge">rsp</code>.
Having this value stored, we then load it in the <code class="language-plaintext highlighter-rouge">rax</code> register in order to inspect it in GDB.
We can output the value of <code class="language-plaintext highlighter-rouge">rax</code>, which is supposed ton contain the value 42, with <code class="language-plaintext highlighter-rouge">print $rax</code> :</p>

<p><code class="language-plaintext highlighter-rouge">$3 = 4294967338</code> ???</p>

<p>Oh! The Value of <code class="language-plaintext highlighter-rouge">rax</code> is not what we expected.
In fact, when managing memory stored in the stack it is important to correctly specify the number of bytes that is being accessed and manipulated.</p>

<h4 id="reading-from-and-writing-to-the-stack">Reading from and writing to the stack</h4>

<p>If you carefully followed the previous code, we added additional directives when moving the value 42 to the stack.
Indeed, when writing to or reading from a memory address, the program requires us to specify the number of bytes to access as it has no other way to know it.
The instruction <code class="language-plaintext highlighter-rouge">mov [rsp], dword ptr 42</code> then means that we are writing the value 42 into at the address stored in <code class="language-plaintext highlighter-rouge">rsp</code>, encoded over 8 bytes (dword standing from double word, where a word corresponds to 4 bytes).
There exists actually several versions of instructions like <code class="language-plaintext highlighter-rouge">mov</code> that dictates the number of bytes to consider, but the exact version to use is inferred by the compiler.</p>

<p>When specifying <code class="language-plaintext highlighter-rouge">mov rax, [rsp]</code>, the program would consider that we are reading 8 bytes from the stack, inferred from the fact that <code class="language-plaintext highlighter-rouge">rax</code> is an 8 bytes register.
Since we actually reserved 4 bytes, the additional 4 bytes the program is reading from in the stack are undefined and as a result <code class="language-plaintext highlighter-rouge">rax</code> contains undefined bits.</p>

<p>The solution here consists in using a register with the proper size in order tell our program to read the correct number of bytes.
In fact, several 8 bytes registers such as <code class="language-plaintext highlighter-rouge">rax</code>, <code class="language-plaintext highlighter-rouge">rbx</code>, <code class="language-plaintext highlighter-rouge">rcx</code> etc.. exist in multiple versions with various sizes.
We will fix our previous issue by using the 4 bytes version of <code class="language-plaintext highlighter-rouge">rax</code> which is named <code class="language-plaintext highlighter-rouge">eax</code>.
We can replace our instruction by : <code class="language-plaintext highlighter-rouge">mov eax, [rsp]</code>.
In GDB, the command <code class="language-plaintext highlighter-rouge">print $eax</code> now gives : <code class="language-plaintext highlighter-rouge">$3 = 42</code>!
Perfect, we are now able to reserve some space in memory to store our local variables.</p>

<p>Note the difference between the instruction <code class="language-plaintext highlighter-rouge">mov</code> used here and <code class="language-plaintext highlighter-rouge">lea</code> that we encountered in the previous posts.
<code class="language-plaintext highlighter-rouge">mov</code> is used to put a value into a register or at a memory address while, <code class="language-plaintext highlighter-rouge">lea</code> which stands for ‚ÄúLoad Effective Address‚Äù, will rather consider the memory address, without accessing the value at that address.</p>

<h4 id="defining-a-stack-frame">Defining a stack frame</h4>

<p>We have just seen how to ‚Äúreserve‚Äù some space in the stack by subtracting from the stack pointer the desired number of bytes to reserve.
We then accessed our memory space by directly using the <code class="language-plaintext highlighter-rouge">rsp</code> value, which then contained the address of our first byte.
However, the stack is meant to grow further as the code of our function (and sub functions) would be executed.
This makes our reference address stored in <code class="language-plaintext highlighter-rouge">rsp</code> invalid as soon as additional data is pushed into the stacK.
This is why we need an invariant reference to access our variables in the function.</p>

<p>In assembly, the <strong>stack frame</strong> designates the space of the stack that is reserved for our function.
In the previous example, our stack goes from the address stored in <code class="language-plaintext highlighter-rouge">rsp</code> to this same address minus the reserved 4 bytes.
As the top of the stack would potentially change when executing the function, we should save a reference address before allocating in the stack so that we can refer to our data from ‚Äúbellow‚Äù.
This is exactly the function of the <code class="language-plaintext highlighter-rouge">rbp</code> pointer (the <strong>b</strong>ase <strong>p</strong>ointer).</p>

<p>We can now modify the previous program by saving the value of <code class="language-plaintext highlighter-rouge">rsp</code> into <code class="language-plaintext highlighter-rouge">rbp</code>.
This time, we will store two 4-bytes values by reserving a total of 8 bytes.
Then, at the end of the function, the stack will be de-allocated and the previous value of <code class="language-plaintext highlighter-rouge">rbp</code> will be restored from <code class="language-plaintext highlighter-rouge">rsp</code>.</p>
<blockquote>
  <p>Keep in mind that registers such as <code class="language-plaintext highlighter-rouge">rsp</code> and <code class="language-plaintext highlighter-rouge">rbp</code> are being used by other functions in our program and they should be preserved across function calls.</p>
</blockquote>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">_start</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="nl">_start:</span>

    <span class="c1">; allocating 4 bytes in the stack</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span> <span class="c1">; save the current stack address in the rbp register</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">8</span> <span class="c1">; allocate two 4-bytes variables in the stack</span>
    <span class="c1">; First variable, address=[rbp-4], size = 4 bytes</span>
    <span class="c1">; Second variable, address=[rbp-8], size = 4 bytes</span>

    <span class="c1">; storing the values 40 and 2 to our 2 variables in the stack</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="mi">40</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="mi">2</span>

    <span class="c1">; computing the sum of the values previously stored</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
    <span class="nf">add</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
    
    <span class="c1">; memory is de-allocated by restoring the original rsp value</span>
    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>

    <span class="c1">; exit</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">60</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">syscall</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Compared to the previous example, we refer this time to our variables by subtracting a corresponding number of bytes from the address in <code class="language-plaintext highlighter-rouge">rbp</code>, our stack base.
I added 1 line of comment for each variable allocated with its size and offset for the readability of our code.
Since the stack grows toward lower addresses, we access our variables by offsetting the base address with their size in bytes and the size of their preceding variables.
The values of our variables will be read from lower to higher adresses which is why we need to subtract their entier size from the base address.</p>

<p>Once again, variables can be inspected with GDB after compiling in debug mode.
We would run GDB and add a breakpoint at <code class="language-plaintext highlighter-rouge">code.s:19</code> in order to print the <code class="language-plaintext highlighter-rouge">eax</code> register.
You will notice that inspecting memory rapidly becomes difficult since the values should be stored into some register in order to be printed.
There is actually a command named <a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_55.html">examine</a> in GDB to look at a specific location in memory, by providing an address.</p>

<h2 id="drawing-a-circle-in-assembly">Drawing a circle in assembly</h2>

<p>Now that we are able to define variables and perform control flow in assembly, our programs become much more interesting.
To demonstrate theses notions, we will modify our square drawing program from the previous post in order to draw a circle.
We start from the following base (I included only the drawing part for clarity) :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="nf">mov</span> <span class="nv">r9</span><span class="p">,</span> <span class="mi">0</span>
<span class="nl">.L_for_loop_rows:</span>    

    <span class="nf">mov</span> <span class="nv">r8</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nl">.L_for_loop_columns:</span>

        <span class="c1">; printing a star</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">star_character</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">syscall</span>

        <span class="c1">; printing a space</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">sp</span><span class="nv">ace_character</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">syscall</span>

        <span class="nf">inc</span> <span class="nv">r8</span>
        <span class="nf">cmp</span> <span class="nv">r8</span><span class="p">,</span> <span class="p">[</span><span class="nv">square_size</span><span class="p">]</span>
        <span class="nf">jne</span> <span class="nv">.L_for_loop_columns</span>

    <span class="c1">; printing a new line</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">new_line</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">syscall</span>
            
    <span class="nf">inc</span> <span class="nv">r9</span>
    <span class="nf">cmp</span> <span class="nv">r9</span><span class="p">,</span> <span class="p">[</span><span class="nv">square_size</span><span class="p">]</span>
    <span class="nf">jne</span> <span class="nv">.L_for_loop_rows</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="storing-indexes-on-the-stack">Storing indexes on the stack</h4>

<p>The first step will be to modify the program and store the index variables in the stack. 
We can replace the r8 and r9 registers by allocating two 8-bytes variables in the stack.
The code is similar to what we saw previously :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>
<span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">16</span>
<span class="c1">; row index : offset=8, size=8</span>
<span class="c1">; column index : offset=16, size=8</span>

<span class="nf">mov</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="mi">0</span> <span class="c1">; row index var is set to 0</span>
<span class="nl">.L_for_loop_rows:</span>    

    <span class="nf">mov</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="mi">0</span> <span class="c1">; col index var is set to 0</span>
    <span class="nl">.L_for_loop_columns:</span>

        <span class="c1">; printing a star</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">star_character</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">syscall</span>

        <span class="c1">; printing a space</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">sp</span><span class="nv">ace_character</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">syscall</span>

        <span class="c1">; increment col index var</span>
        <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>
        <span class="c1">; test column loop termination</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>
        <span class="nf">cmp</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nv">square_size</span><span class="p">]</span>
        <span class="nf">jne</span> <span class="nv">.L_for_loop_columns</span>

    <span class="c1">; writing a new line</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">new_line</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">syscall</span>
        
    <span class="c1">; increment col index var</span>
    <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
    <span class="c1">; test row loop termination</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
    <span class="nf">cmp</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nv">square_size</span><span class="p">]</span>
    <span class="nf">jne</span> <span class="nv">.L_for_loop_rows</span>

<span class="c1">; memory de-allocation</span>
<span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We have previously seen how to allocate two variables on the stack.
The changes regarding the previous version of our program are symmetrical for the two index variables for rows and columns.
The two variables are first assigned to 0.
This time, it is necessary to specify their size with <code class="language-plaintext highlighter-rouge">qword ptr</code> for 8 bytes, and they are references through an offset relatively to the address in <code class="language-plaintext highlighter-rouge">rbp</code>.</p>

<p>After a loop iteration, the indexes are incremented in a similar way.
The <code class="language-plaintext highlighter-rouge">cmp</code> operation is then performed to test for the loop termination condition.
Here, you will notice that the variable is stored into the <code class="language-plaintext highlighter-rouge">rax</code> register instead of being directly referenced in the <code class="language-plaintext highlighter-rouge">cmp</code> instruction.
This is because an instruction cannot be given two memory references, only one is allowed and the other one must be a register.
In the previous version, we saw that the <code class="language-plaintext highlighter-rouge">rax</code> register could not be used to store our index since it was already used elsewhere in the program.
Using this register here is not an issue since it is only used as a temporary location to perform the test.</p>

<h4 id="drawing-a-circle">Drawing a circle</h4>

<p>Now that we have a better base, let‚Äôs draw the circle.
The circle will be centered in the center of the square and its diameter will be the square‚Äôs length.
For each character position, we will test if the character belongs to the circle or not.
This is performs by calculating the distance between the character‚Äôs position and the center of the circle.
If the distance is smaller or equal to the radius of the circle, the character can be printed.
Writing it as a pseudocode first will help in our assembly implementation :</p>

<div class="code_frame"> Pseudocode </div>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>const square_size

var row_index
var col_index
var square_center
var radius_squared
var distance_squared

square_center &lt;- square_size / 2
radius_squared &lt;- (square_size / 2)¬≤

distance_squared &lt;- (row_index-square_center)¬≤ + (col_index-square_center)¬≤ 

if distance_squared &lt;= radius_squared 
    draw '*'
else:
    draw ' '
endif
</pre></td></tr></tbody></table></code></pre></figure>

<p>In this pseudocode, I decomposed the instructions in order to simplify the assembly implementation.
You may first notice that instead of compute distances, we compute squared distances to avoid calculating a square root.
This implied having the square radius value stored somewhere, this will be one of our local variable.
We also add a local variable to store the center of the square, which is half its size.
Our last variable is a temporary variable used to store the squared distance, so that it can be compare to the square radius.</p>

<h4 id="defining-the-local-variables">Defining the local variables</h4>

<p>Let‚Äôs write or new stack allocation from this :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>
<span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">40</span>
<span class="c1">; row index : offset=8, size=8</span>
<span class="c1">; column index : offset=16, size=8</span>
<span class="c1">; square center : offset=24, size=8</span>
<span class="c1">; radius squared : offset=32, size=8</span>
<span class="c1">; distance squared : offset=40, size=8</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can then add two lines to assign the square center and radius squared variables at the beginning of our function, as their value won‚Äôt change :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="c1">; rax is temporary used to compute square_size/2</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nv">square_size</span><span class="p">]</span>
<span class="nf">shr</span> <span class="nb">rax</span>
<span class="c1">; storing the value in the square center variable</span>
<span class="nf">mov</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">],</span> <span class="nb">rax</span>

<span class="c1">; rax is squared</span>
<span class="nf">imul</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="c1">; storing the squared radius</span>
<span class="nf">mov</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">],</span> <span class="nb">rax</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The rax register is used temporarily to compute the values of our variables.
The square center variable is the first one to be assigned.
It is not easy to read but the division of the square size by 2 is performed by the <code class="language-plaintext highlighter-rouge">shr</code> operation.
<code class="language-plaintext highlighter-rouge">shr</code> is a common instruction in programming that performs ‚Äúbits shift‚Äù (to the right in this case) : the rightmost bit of the value is lost and all the other ones are shifted to the right.
This as the effect of efficiently dividing the value by 2 (this line could be replaced by a more complexe divide instruction).</p>

<p>After assigning the square center variable, the value of rax is squared in order to obtain the squared radius.
The <code class="language-plaintext highlighter-rouge">imul</code> instruction is used here to perform an integer multiplication of the register with itself.</p>

<h4 id="computing-the-distance-and-drawing-the-circle">Computing the distance and drawing the circle</h4>

<p>We can now add the last missing piece of code that compare the distances and decide if the printed character should be a star ‚Äò*‚Äô or a space ‚Äò ‚Äò :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="c1">; compute (row_index - square_center)¬≤ into distance_squared</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">sub</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
<span class="nf">imul</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">40</span><span class="p">],</span> <span class="nb">rax</span>

<span class="c1">; add (col_index - square_center)¬≤ to distance_squared</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>
<span class="nf">sub</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
<span class="nf">imul</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">add</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">40</span><span class="p">],</span> <span class="nb">rax</span>

<span class="c1">; compare distance_squared to radius_squared</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span>
<span class="nf">cmp</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">40</span><span class="p">],</span> <span class="nb">rax</span>
<span class="nf">jge</span> <span class="nv">.L_print_space</span>

<span class="c1">; .L_print_star:</span>
    <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">star_character</span><span class="p">]</span>
    <span class="nf">jmp</span> <span class="nv">.L_end_print</span>
<span class="nl">.L_print_space:</span>
    <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">sp</span><span class="nv">ace_character</span><span class="p">]</span>
<span class="nl">.L_end_print:</span>

<span class="c1">; printing the chosen character</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">syscall</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Once again, we use the <code class="language-plaintext highlighter-rouge">rax</code> register as a temporary register to compute our values.
The first two groups of lines correspond to the computation of the squared distance between the current character and the center.</p>

<p>The distance is the compared to the squared radius in order to select the right character to be printed.
In this code, the conditional statement is used for setting the <code class="language-plaintext highlighter-rouge">rsi</code> register only, which contains the address of the character strings to be printed with ‚Äúsys_write‚Äù.
Indeed, the value of the other registers do not change between the two cases.</p>

<p>And voil√†, our circle is now printed to the terminal :</p>

<div class="code_frame"> Bash </div>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>            * * * * * * * * *           
          * * * * * * * * * * *         
      * * * * * * * * * * * * * * *     
      * * * * * * * * * * * * * * *     
    * * * * * * * * * * * * * * * * *   
  * * * * * * * * * * * * * * * * * * * 
  * * * * * * * * * * * * * * * * * * * 
  * * * * * * * * * * * * * * * * * * * 
  * * * * * * * * * * * * * * * * * * * 
  * * * * * * * * * * * * * * * * * * * 
  * * * * * * * * * * * * * * * * * * * 
  * * * * * * * * * * * * * * * * * * * 
  * * * * * * * * * * * * * * * * * * * 
  * * * * * * * * * * * * * * * * * * * 
    * * * * * * * * * * * * * * * * *   
      * * * * * * * * * * * * * * *     
      * * * * * * * * * * * * * * *     
          * * * * * * * * * * *         
            * * * * * * * * *           
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="whats-next-">What‚Äôs next ?</h2>

<p>By interacting with the stack to store our variables, our program is now much cleaner.
There is still a lot to say about the stack, in particular how to properly use it when calling function.
We will discuss function calls in details in the next chapter of the series.</p>

<p>By the time, you will find the complete code for drawing the circle at <a href="https://github.com/smbct/x86-64_101_linux/tree/main/pt3_draw_circle">that address</a>.
Many improvements are still possible such as defining a circle radius that is different from the size of the square.
Once again, do not hesitate to share your thoughts in the comments, I will welcome your feedbacks!</p>

    



<div class="post-tags">
  
</div>
  </div>

  

  
  <section class="comments">
    <!-- <h2>Comments</h2> -->
    <script src="https://giscus.app/client.js"
        data-repo="smbct/smbct.github.io"
        data-repo-id="R_kgDOL0ffhg"
        data-category="Announcements"
        data-category-id="DIC_kwDOL0ffhs4CfYJ5"
        data-mapping="title"
        data-strict="1"
        data-reactions-enabled="0"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
  </script>

  </section>


</div>




<p class="back-link">
    <a href="/series/x86_64_assembly/headline.html"><span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>Assembly x86-64 programming 101</a>
</p>


    </main>

    <!-- Optional footer content -->

  </body>
</html>
