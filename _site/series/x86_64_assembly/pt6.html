<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Assembly x86 programming 101 &#58 part 6, sorting arrays &middot; smbct's blog
    
  </title>

  <!-- 
 -->

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="series_article">

    <div id="sidebar">
  <header>
    <div class="site-title">
      <a href="/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        smbct's blog
      </a>
    </div>
    <p class="lead">Notes on computer science, programming, society and more.</p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link "
        href="/">Home</a>
  
  

  

  


  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  



  <a class="category-link "
          href="/pages/series.html">Series </a>

  


  
    
  

  
    
      <a class="category-link "
          href="/pages/about.html">About</a>
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">

  
    <a id="github-link"
       class="icon" title="Github Profile" aria-label="Github Profile"
       href="https://github.com/smbct">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 28" height="24" width="28"><path d="M12 2c6.625 0 12 5.375 12 12 0 5.297-3.437 9.797-8.203 11.391-0.609 0.109-0.828-0.266-0.828-0.578 0-0.391 0.016-1.687 0.016-3.297 0-1.125-0.375-1.844-0.812-2.219 2.672-0.297 5.484-1.313 5.484-5.922 0-1.313-0.469-2.375-1.234-3.219 0.125-0.313 0.531-1.531-0.125-3.187-1-0.313-3.297 1.234-3.297 1.234-0.953-0.266-1.984-0.406-3-0.406s-2.047 0.141-3 0.406c0 0-2.297-1.547-3.297-1.234-0.656 1.656-0.25 2.875-0.125 3.187-0.766 0.844-1.234 1.906-1.234 3.219 0 4.594 2.797 5.625 5.469 5.922-0.344 0.313-0.656 0.844-0.766 1.609-0.688 0.313-2.438 0.844-3.484-1-0.656-1.141-1.844-1.234-1.844-1.234-1.172-0.016-0.078 0.734-0.078 0.734 0.781 0.359 1.328 1.75 1.328 1.75 0.703 2.141 4.047 1.422 4.047 1.422 0 1 0.016 1.937 0.016 2.234 0 0.313-0.219 0.688-0.828 0.578-4.766-1.594-8.203-6.094-8.203-11.391 0-6.625 5.375-12 12-12zM4.547 19.234c0.031-0.063-0.016-0.141-0.109-0.187-0.094-0.031-0.172-0.016-0.203 0.031-0.031 0.063 0.016 0.141 0.109 0.187 0.078 0.047 0.172 0.031 0.203-0.031zM5.031 19.766c0.063-0.047 0.047-0.156-0.031-0.25-0.078-0.078-0.187-0.109-0.25-0.047-0.063 0.047-0.047 0.156 0.031 0.25 0.078 0.078 0.187 0.109 0.25 0.047zM5.5 20.469c0.078-0.063 0.078-0.187 0-0.297-0.063-0.109-0.187-0.156-0.266-0.094-0.078 0.047-0.078 0.172 0 0.281s0.203 0.156 0.266 0.109zM6.156 21.125c0.063-0.063 0.031-0.203-0.063-0.297-0.109-0.109-0.25-0.125-0.313-0.047-0.078 0.063-0.047 0.203 0.063 0.297 0.109 0.109 0.25 0.125 0.313 0.047zM7.047 21.516c0.031-0.094-0.063-0.203-0.203-0.25-0.125-0.031-0.266 0.016-0.297 0.109s0.063 0.203 0.203 0.234c0.125 0.047 0.266 0 0.297-0.094zM8.031 21.594c0-0.109-0.125-0.187-0.266-0.172-0.141 0-0.25 0.078-0.25 0.172 0 0.109 0.109 0.187 0.266 0.172 0.141 0 0.25-0.078 0.25-0.172zM8.937 21.438c-0.016-0.094-0.141-0.156-0.281-0.141-0.141 0.031-0.234 0.125-0.219 0.234 0.016 0.094 0.141 0.156 0.281 0.125s0.234-0.125 0.219-0.219z"></path>
</svg>

    </a>
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  

  <!-- Optional additional links to insert for icons links -->
</nav>

  <p>
  &copy; 2024.
  <a href="/LICENSE.md">MIT License.</a>
</p>

</div>

    <main class="container">
      <header>
  


<p class="back-link">
    <a href="/series/x86_64_assembly/headline.html"><span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>Assembly x86 programming 101</a>
</p>


  <h1 class="post-title">Assembly x86 programming 101 &#58 part 6, sorting arrays</h1>
</header>
<div class="content">
  <div class="post-meta">
  <span class="post-date">üìÖ 20 Jun 2024</span>

  
  ‚Ä¢ ‚è≤Ô∏è
  <!-- taken from https://carlosbecker.com/posts/jekyll-reading-time-without-plugins/ -->

<span class="reading-time" title="Estimated read time">
  
  
    41 mins
  
</span>
  

  <span class="post-categories">
    
      &bull;

      
      
      

      
        low-level programming assembly
      
    
  </span>
</div>



  <div class="post-body">
    <p>Having covered the basics of assembly programming, we can now put some knowledge into practice by writing concrete algorithms.
In this post, we will write classical <strong>sorting algorithms</strong>.
This will be the occasion to further manipulate the stack and to work on the modular organization of our code.</p>

<h2 id="modular-assembly-programs">Modular assembly programs</h2>

<p>We will start this part with our code from the previous part that prints arrays.
This time, we are going to separate our code in different files to organize our different functions.
We start with two different files : a first one containing the <code class="language-plaintext highlighter-rouge">print_array</code> function and a second one containing the main function (we will continue using the standard libc here).
Here are our two code files :</p>

<div class="collapse-panel"><div>
<label for="code_1">Expand</label>
<input type="checkbox" name="" id="code_1" /><span class="collapse-label"></span>
<div class="extensible-content">

<div class="code_frame"> Assembly x86-64 | main.s </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">main</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="c1">; main function (libc main)</span>
<span class="nl">main:</span>
    
    <span class="nf">push</span> <span class="nb">rbp</span> <span class="c1">; storing the rbp value before manipulation</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span> <span class="c1">; storing the rsp register</span>

    <span class="c1">; the stack would be allocated here</span>

    <span class="c1">; saving the preserved registers</span>
    <span class="nf">push</span> <span class="nb">rdi</span>
    <span class="nf">push</span> <span class="nb">rsi</span>

    <span class="c1">; printing the "My array : " string</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_str</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">printf</span>

    <span class="c1">; calling the print_array function with parameters</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">si</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_length</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">print_array</span>

    <span class="c1">; printing a new line</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">new_line</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">printf</span>

    <span class="c1">; restoring the preserved registers</span>
    <span class="nf">pop</span> <span class="nb">rsi</span>
    <span class="nf">pop</span> <span class="nb">rdi</span>

    <span class="c1">; restoring the rsp and rbp registers</span>
    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>

    <span class="c1">; return</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">ret</span>

<span class="nl">my_array:</span>
    <span class="nf">.byte</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">14</span>
<span class="nl">my_array_length:</span>
    <span class="nf">.word</span> <span class="mi">9</span>

<span class="nl">new_line:</span>
    <span class="nf">.asciz</span> <span class="err">"\</span><span class="nv">n</span><span class="s">"
my_array_str:
    .asciz "</span><span class="nv">My</span> <span class="nv">array</span> <span class="p">:</span> <span class="err">"</span>
</pre></td></tr></tbody></table></code></pre></figure>

</div></div></div>

<div class="collapse-panel"><div>
<label for="code_2">Expand</label>
<input type="checkbox" name="" id="code_2" /><span class="collapse-label"></span><div class="extensible-content">

<div class="code_frame"> Assembly x86-64 | print_array.s </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">print_array</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="c1">; print an array (encoded on bytes)</span>
<span class="c1">; rdi : array pointer</span>
<span class="c1">; si : array length</span>
<span class="nl">print_array:</span>

    <span class="c1">; storing the rsp value before manipulation</span>
    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="c1">; rbp - 8 : array pointer, 8 bytes</span>
    <span class="c1">; rbp - 10 : array index, 2 bytes</span>
    <span class="c1">; rbp - 12 : array size, 2 bytes</span>
    <span class="c1">; 4 padding bytes</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">16</span>
    
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">rdi</span> <span class="c1">; loading the array pointer</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="mi">0</span> <span class="c1">; array_index &lt;- 0</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">],</span> <span class="nb">si</span> <span class="c1">; loading the array length</span>

    <span class="nl">.L_for_loop_writing_1:</span>

        <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
        <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">array_elt_formatter</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="c1">; load the array pointer</span>
        <span class="nf">mov</span> <span class="nb">si</span><span class="nv">l</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">]</span> <span class="c1">; load the value stored at the address</span>
        <span class="nf">call</span> <span class="nv">printf</span>

        <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="c1">; increase the array pointer</span>
        <span class="nf">inc</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="c1">; increase the array index</span>
        <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>
        <span class="nf">cmp</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">bx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>

        <span class="nf">jne</span> <span class="nv">.L_for_loop_writing_1</span> <span class="c1">; test if all characters have been printed</span>

    <span class="c1">; restoring the rsp value</span>
    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>

    <span class="nf">ret</span>

<span class="nl">array_elt_formatter:</span>
    <span class="nf">.asciz</span> <span class="s">"%hhd "</span>
</pre></td></tr></tbody></table></code></pre></figure>

</div></div></div>

<p>The difference with the previous version is the presence of two parameters for our <code class="language-plaintext highlighter-rouge">print_array</code> function : an address (pointer) to the first element of the array and its length.
You may notice that for the two files, the function‚Äôs symbols have been defined as <code class="language-plaintext highlighter-rouge">global</code> symbols, allowing our final program to record their name.</p>

<p>Regarding the <code class="language-plaintext highlighter-rouge">main</code> function, we also cautiously save the <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">rsi</code> registers in the stack as they are overwritten in our function.
They are indeed supposed to be <strong>preserved</strong> registers in the C language and since these registers are used in our function to pass parameters, it is necessary to save them.
You may refer to the <a href="https://i.sstatic.net/j8hpC.png">table</a> given in the <a href="https://stackoverflow.com/questions/38335212/calling-printf-in-x86-64-using-gnu-assembler">stackoverflow</a> post that was already linked in the previous part for the other registers to preserve.</p>

<p>To compile (assemble) this program, we first assemble separately our two code files : <code class="language-plaintext highlighter-rouge">as main.s -o main.o &amp;&amp; as print_array.s -o print_array.o</code>.
Then, we combine the files with gcc to create the final executable : <code class="language-plaintext highlighter-rouge">gcc -static main.o print_array.o -o main</code>.
Simple! üòÄ</p>

<h2 id="copying-an-array">Copying an array</h2>

<p>For now, we have a program that prints an array.
Our problem is that the array is stored in the program‚Äôs memory as a constant : it cannot be modified. during its execution üîÇ.
In order to modify an array, it is then necessary to store it in a writable <a href="https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation/?ref=header_searchplace">place</a> : on the heap üçö or in the stack ü•û.</p>

<p>In our case, we can copy the array in the <strong>stack</strong> as we previously saw how to manipulate it.
In our program, the length of the array will be given as a parameter in order to manage different sizes.
This implies that we will perform a <strong>dynamical</strong> allocation on the stack, something that is not usually done in languages such as C.</p>

<h4 id="dynamic-allocation-on-the-stack">Dynamic allocation on the stack</h4>

<p>We know that allocations on the stack are performed by subtracting a given number of bytes from the stack pointer. 
One problem that arises from this design choice is that it is no longer possible to know in advance how to modify the <code class="language-plaintext highlighter-rouge">rsp</code> pointer to verify the <em>16</em> bytes alignment discussed previously.</p>

<p>This step can however be executed automatically.
To see how, let‚Äôs add the <code class="language-plaintext highlighter-rouge">sub rsp, 7</code> instruction at line 11 in our previous main function.
We can then use gdb to display the <code class="language-plaintext highlighter-rouge">rsp</code> point by adding a breakpoint juste after this instruction :</p>

<div class="code_frame"> GDB </div>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre>(gdb) b main.s:20
Breakpoint 1 at 0x40168d: file main.s, line 22.
(gdb) run
...
(gdb) p/t $rsp
$1 = 11111111111111111111111111111111101101111011001
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">p/t</code> command in gdb allow to display a value (register for instance) in the binary format.
We can see the misalignment of the stack pointer here by looking at the last 4 digits (bits) of this number.
Indeed, in base 10, <em>16=2^4</em>, hence the last 4 bits of the number encode values from <em>0</em> to <em>15</em>.</p>

<p>Thus our stack pointers address currently ends with <em>1001</em> in binary, which is <em>9</em> in decimal.
The misalignment is equal to <em>16-9=7</em>, which corresponds to our previous allocation of 7 bytes (the stack was previously correctly aligned).
As the stack grows downward, it is necessary to subtract the right amount of bytes in order to re-align the stack pointer.
This step is actually straightforward in assembly : we need to subtract <em>rsp modulo 16</em> to our <code class="language-plaintext highlighter-rouge">rsp</code> pointer.</p>

<blockquote>
  <p>üìù Note that here we are considering that the binary numbers‚Äô first bytes are on the right.
This is in fact a question of convention with the choice of the <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a>.</p>
</blockquote>

<p>To compute <em>rsp mod 16</em>, we can simply compute a logical <strong>and</strong> with the binary number <strong>1 1 1 1</strong> (15 in decimal), hence isolating the last four bytes of the number :</p>

<font size="4">  
<pre style="font-size: 80%; border: solid 1px; padding: 0.3rem; border-radius:0.3rem;">
    [...] <span style="color: blue;"> 1 0 1 1 0 1 1 1 1 0 1</span> <strong>1 0 0 1</strong> &lt;- rsp
and [...] <span style="color: red;"> 0 0 0 0 0 0 0 0 0 0 0</span> <strong>1 1 1 1</strong> &lt;- 15
    ------------------------------------
    [...] <span style="color: red;"> 0 0 0 0 0 0 0 0 0 0 0</span> <strong>1 0 0 1</strong>
</pre>
</font>

<p>We can then use the <code class="language-plaintext highlighter-rouge">xor</code> operation (exclusive or) between our original address and the isolated 4 last bytes in order to turn all these 4 bytes into zeros :</p>

<font size="4">  
<pre style="font-size: 80%; border: solid 1px; padding: 0.3rem; border-radius:0.3rem;">
    [...] <span style="color: blue;"> 1 0 1 1 0 1 1 1 1 0 1</span> <strong>1 0 0 1</strong> &lt;- rsp
xor [...]  <span style="color: red;">0 0 0 0 0 0 0 0 0 0 0</span> <strong>1 0 0 1</strong> &lt;- rsp mod 16
    ------------------------------------
    [...] <span style="color: blue;"> 1 0 1 1 0 1 1 1 1 0 1</span> <strong>0 0 0 0</strong> &lt;- rsp - (rsp mod 16)
</pre>
</font>

<p>Let‚Äôs achieve these operations in practice after our 7 bytes allocation :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="c1">; allocate any number of bytes in the stack</span>
<span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">7</span>

<span class="c1">; automatic 16 bytes alignement of stack pointer rsp    </span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rsp</span> <span class="c1">; temporary storing the stack pointer</span>
<span class="nf">and</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">15</span> <span class="c1">; computing rsp modulo 16 to compute the misalignment</span>
<span class="nf">xor</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rax</span> <span class="c1">; subtracting the additional bytes with a xor operation</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can now add a breakpoint after these instructions and check the binary value of <code class="language-plaintext highlighter-rouge">rsp</code> with gdb :</p>

<div class="code_frame"> GDB </div>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>(gdb) b main.s:25
Breakpoint 1 at 0x401697: file main.s, line 27.
(gdb) run
...
Breakpoint 1, main () at main.s:27
27	    push rdi
(gdb) p/t $rsp
$1 = 11111111111111111111111111111111101101111010000
</pre></td></tr></tbody></table></code></pre></figure>

<p>Yay! The last 4 bytes are now all zeroes! ü•≥</p>

<h4 id="a-copy-array-function">A copy array function</h4>

<p>Let‚Äôs now write our <code class="language-plaintext highlighter-rouge">copy_array</code> function that allows to copy an array from one location (memory address) to other one.
Note üìù that this function does not actually need to manipulate the stack or allocate any memory space.
The allocation would be performed by the calling function and the only use of the function is to manipulate memory at that memory space to copy the array.</p>

<p>Let‚Äôs create a base file for this function :</p>

<div class="code_frame"> Assembly x86-64 | copy_array.s </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">copy_array</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="c1">; copy an array from one address to another one</span>
<span class="c1">; array elements are coded on 1 byte </span>
<span class="c1">; rdi: address of the array</span>
<span class="c1">; si: length of the array</span>
<span class="c1">; rdx: target address of the array</span>
<span class="nl">copy_array:</span>

    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="c1">; local variables allocation</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">32</span> <span class="c1">; 20 bytes allocation + 12 bytes for stack pointer alignment</span>

    <span class="c1">; rbp-8 (8 bytes) original array address</span>
    <span class="c1">; rbp-10 (2 bytes) array length</span>
    <span class="c1">; rbp-18 (8 bytes) address of the target array</span>
    <span class="c1">; rbp-20 (2 bytes) array index</span>

    <span class="c1">; saving preserved registers</span>
    <span class="nf">push</span> <span class="nb">rdi</span>
    <span class="nf">push</span> <span class="nb">rsi</span>

    <span class="c1">; copy the array</span>
    <span class="c1">; ...</span>

    <span class="c1">; restoring preserved registers</span>
    <span class="nf">pop</span> <span class="nb">rsi</span>
    <span class="nf">pop</span> <span class="nb">rdi</span>

    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>

    <span class="nf">ret</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Our new function takes three parameters, passed by registers : the address of the original array on 8 bytes, its length on 2 bytes and the address of the new array on 8 bytes.
These 3 parameters are stored in the stack.
One additional local variable is allocated to store an array index.</p>

<p>Just after the stack allocation, we can initialize our local variables.
The local variables corresponding to the parameters are initialized from their respective values and the index is initialized to 0 :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">rdi</span> <span class="c1">; rdi: original address</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="nb">si</span> <span class="c1">; rsi: array length</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">18</span><span class="p">],</span> <span class="nb">rdx</span> <span class="c1">; address of the target array</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">20</span><span class="p">],</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="mi">0</span> <span class="c1">; array index</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Then, the function should iterate over all elements of the arrays and copy the values from the original array to the target array.
This part is to be inserted at lines 26-27 of our ‚Äúcopy_array.s‚Äù backbone :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="nl">.L_push_array:</span>

    <span class="c1">; store the value from origin to target address</span>
    <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> 
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdx</span><span class="p">]</span> <span class="c1">; get the value</span>

    <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">18</span><span class="p">]</span> <span class="c1">; load the address</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rdx</span><span class="p">],</span> <span class="nb">al</span>

    <span class="c1">; go to the next addresses</span>
    <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
    <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">18</span><span class="p">]</span>

    <span class="c1">; increment index and test length limit</span>
    <span class="nf">inc</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">20</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>
    <span class="nf">cmp</span> <span class="nb">ax</span><span class="p">,</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">20</span><span class="p">]</span>
    <span class="nf">jne</span> <span class="nv">.L_push_array</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This algorithm is essentially a ‚Äúfor‚Äù loop that iterate over both array elements.
The goal of the first part of the loop is to store the value of the original array into a 1-byte register.
Two operations are necessary to store or write the value into the array since the first one only recover the address of the value.</p>

<p>After this copy operation, the adresses are increased to point toward ‚ÜóÔ∏è the next array elements.
Finally, the array index (2 bytes) is increased and its value is compared to the array length in order to decide if a new iteration is required üîÅ.</p>

<h4 id="testing-our-copy-function">Testing our copy function</h4>

<p>Let‚Äôs now complete our main function to test our <code class="language-plaintext highlighter-rouge">copy_array</code> function.
The first step is the allocation of the copy array in the stack.
To do so, we first allocate 8 bytes right after the <code class="language-plaintext highlighter-rouge">rbp</code> address in order to store the array copy address, and then, we allocate the sufficient number of bytes to store the array :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="c1">; stack allocation</span>
<span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">8</span> <span class="c1">; store the address of the array copy</span>
<span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_length</span><span class="p">]</span> <span class="c1">; the length is stored on a word : 4 bytes -&gt; ax registers</span>
<span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rax</span> <span class="c1">; store the array</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>After that, we can insert the code that stores the address of the new array and the one that calls the <code class="language-plaintext highlighter-rouge">copy_array</code> function, right after saving the preserved registers :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="c1">; store the address of the array copy</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">rsp</span>

<span class="c1">; copy the array</span>
<span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nv">my_array</span>
<span class="nf">mov</span> <span class="nb">si</span><span class="p">,</span> <span class="nv">my_array_length</span>
<span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">call</span> <span class="nv">copy_array</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>You can see that the address of the new array is directly obtained from the value of the <code class="language-plaintext highlighter-rouge">rsp</code> register.
Indeed, the array was allocated with a <code class="language-plaintext highlighter-rouge">sub</code> operation on <code class="language-plaintext highlighter-rouge">rsp</code>.
Since the stack grows downward ‚¨áÔ∏è, this means that the first address of our array is actually the lowest address of the allocated portion of the stack (assuming the array‚Äôs first element is at the lower address).</p>

<p>Nothing new however regarding the function call, the addresses of the two arrays are given to the registers that take the parameters, as well as the array length.
Let‚Äôs add another printing calls to compare the result.
The final <code class="language-plaintext highlighter-rouge">main</code> function should look like this :</p>

<div class="collapse-panel"><div>
<label for="code_3">Expand</label>
<input type="checkbox" name="" id="code_3" /><span class="collapse-label"></span><div class="extensible-content">

<div class="code_frame"> Assembly x86-64 | main.s </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">main</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="c1">; main function (libc main)</span>
<span class="nl">main:</span>
    
    <span class="nf">push</span> <span class="nb">rbp</span> <span class="c1">; storing the rbp value before manipulation</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span> <span class="c1">; storing the rsp register</span>

    <span class="c1">; stack allocation</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">8</span> <span class="c1">; store the address of the array copy</span>
    <span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_length</span><span class="p">]</span> <span class="c1">; the length is stored on a word : 4 bytes -&gt; ax registers</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rax</span> <span class="c1">; store the array</span>

    <span class="c1">; automatic 16 bytes alignement of rsp    </span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rsp</span> <span class="c1">; temporary storing the stack pointer</span>
    <span class="nf">and</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">15</span> <span class="c1">; computing rsp modulo 16 to compute the misalignment</span>
    <span class="nf">xor</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rax</span> <span class="c1">; subtracting byte to align rsp</span>

    <span class="c1">; storing the preserved registers</span>
    <span class="nf">push</span> <span class="nb">rdi</span>
    <span class="nf">push</span> <span class="nb">rsi</span>

    <span class="c1">; store the address of the array copy</span>
    <span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_length</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">sub</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">8</span>
    <span class="nf">sub</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">rcx</span>

    <span class="c1">; copy the array</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nv">my_array</span>
    <span class="nf">mov</span> <span class="nb">si</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_length</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">copy_array</span>

    <span class="c1">; -------------------------------------------------------------</span>
    <span class="c1">; Print the original array</span>

    <span class="c1">; printing the "My array : " string</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_str</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">printf</span>

    <span class="c1">; calling the print_array function</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">si</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_length</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">print_array</span>

    <span class="c1">; printing a new line</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">new_line</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">printf</span>

    <span class="c1">; -------------------------------------------------------------</span>
    <span class="c1">; Print the copy array</span>

    <span class="c1">; printing the "My array copy : " string</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_copy_str</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">printf</span>

    <span class="c1">; calling the print_array function with parameters</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">si</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_length</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">print_array</span>

    <span class="c1">; printing a new line</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">new_line</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">printf</span>

    <span class="c1">; restoring the preserved registers</span>
    <span class="nf">pop</span> <span class="nb">rsi</span>
    <span class="nf">pop</span> <span class="nb">rdi</span>

    <span class="c1">; restoring the rsp and rbp registers</span>
    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>

    <span class="c1">; return</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">ret</span>

<span class="nl">my_array:</span>
    <span class="nf">.byte</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">14</span>
<span class="nl">my_array_length:</span>
    <span class="nf">.word</span> <span class="mi">9</span>

<span class="nl">new_line:</span>
    <span class="nf">.asciz</span> <span class="err">"\</span><span class="nv">n</span><span class="s">"
my_array_str:
    .asciz "</span><span class="nv">My</span> <span class="nv">array</span> <span class="p">:</span>      <span class="s">"
my_array_copy_str:
    .asciz "</span><span class="nv">My</span> <span class="nv">array</span> <span class="nv">copy</span> <span class="p">:</span> <span class="err">"</span>
</pre></td></tr></tbody></table></code></pre></figure>

</div></div></div>

<p>You should now be able to see the two identical arrays printed in the terminal :</p>

<div class="code_frame"> Bash | main output </div>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre>My array :      5 12 42 8 1 3 7 25 14 
My array copy : 5 12 42 8 1 3 7 25 14
</pre></td></tr></tbody></table></code></pre></figure>

<p>That‚Äôs great! üëè We can now add some additional lines to verify that we are indeed able to modify the array.
To do so, we will load the address of the third element of the copy array and write the value 0 into it :</p>

<div class="code_frame"> x86-64 assembly </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="c1">; modify the copy array</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">2</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rax</span><span class="p">],</span> <span class="kt">byte</span> <span class="nv">ptr</span> <span class="mi">0</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Which gives :</p>

<div class="code_frame"> Bash | main output </div>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre>My array :      5 12 42 8 1 3 7 25 14 
My array copy : 5 12 0 8 1 3 7 25 14 
</pre></td></tr></tbody></table></code></pre></figure>

<p>Perfect! ü•≥ We are now able to store and modify arrays in our codes!</p>

<h2 id="sorting-an-array">Sorting an array</h2>

<p>In this second sub part, we will now implement a sorting algorithm in assembly : the <strong>selection sort</strong> algorithm.
The idea of the selection sort is to successively compute the minimum of sub-arrays of the input one.</p>

<p>In the first step, the algorithm finds the minimum value of the entire array and stores it at the first position.
In the second one, the algorithm then looks for the minimum value of the sub-array starting at the second position.
The algorithm then continues until the sub-array contains only one element.</p>

<h4 id="pseudocode">Pseudocode</h4>

<p>To simplify the implementation, we will start with a pseudocode of the algorithme.
This will help define the local variables and the global structure of the function.</p>

<div class="code_frame"> Pseudocode | selection sort </div>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>* Parameters :
    array : the array (modifiable) to be sorted
    array_len : length of the array

* Local variables :
    outer_index : index to iterate over the array
    inner_index : index to iterate over the sub-arrays
    min_ind : index of the minimum value of a sub-array
    temp : a temporary variable to swap two array values

* Algorithm :

    for outer_index in {1,..,array_len-1}
        
        // init the min value to the first element
        min_ind &lt;- out_index

        // iterate over the sub array array[outer_index+1 : array_len-1]
        for inner_index in {outer_index+1,..,array_len-1}

            if array[inner_index] &lt; array[min_index] then
                min_index &lt;- inner_index
            endif

        endfor

        // swap the first value of the sub-array and the min value
        temp &lt;- array[inner_index]
        array[inner_index] &lt;- array[min_index]
        array[min_index] &lt;- temp

    endfor
</pre></td></tr></tbody></table></code></pre></figure>

<p>In our code, the two parameters will be turned into local variables in order to free their respective registers.
You can also see the two nested loops which which allow to iterate respectively over the complete array and the sub-arrays.
In this configuration, the minimum of each sub-array is recorded through its index.</p>

<h4 id="assembly-implementation">Assembly implementation</h4>

<p>We start our implementation by defining our variables and writing the backbone of the function.
As the pseudocode contains two ‚Äúfor‚Äù loops (the inner and the outer loops), we will used two indexes and two array addresses to control the iterations and access the array elements.
We will also use two additional variables : one to store the min value of the sub arrays in the inner loop, and another one to store a temporary value. (useful for swapping values and storing the min value of sub arrays).</p>

<p>Here is the function‚Äôs backbone :</p>

<div class="code_frame"> Assembly x86-64 | selection_sort.s </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">selection_sort</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="c1">; Sort an array with the selection sort algorithm</span>
<span class="c1">; rdi : array pointer</span>
<span class="c1">; si : array length</span>
<span class="nl">selection_sort:</span>

    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">48</span> 
    <span class="c1">; rbp-8 : (8 bytes) array address (param)</span>
    <span class="c1">; rbp-10 : (2 bytes) array length (param)</span>
    <span class="c1">; rbp-12 : (2 bytes) outer index</span>
    <span class="c1">; rbp-14 : (2 bytes) inner index</span>
    <span class="c1">; rbp-22 : (8 bytes) outer array address</span>
    <span class="c1">; rbp-30 : (8 bytes) inner array address</span>
    <span class="c1">; rbp-32 : (2 bytes) sub-array min index</span>
    <span class="c1">; rbp-33 : (1 byte) temp value for swapping</span>

    <span class="c1">; a) first variable initialization</span>
    <span class="c1">; [...]</span>

    <span class="c1">; ----------------------------------------</span>
    <span class="c1">; outer loop</span>
    <span class="nl">.L_outer_for:</span>

        <span class="c1">; b) init the inner array index and address</span>
        <span class="c1">; [...]</span>

        <span class="c1">; e) init the variables to store the sub array min</span>
        <span class="c1">; [...]</span>

        <span class="c1">; ----------------------------------------</span>
        <span class="c1">; inner loop</span>
        <span class="nl">.L_inner_for:</span>

            <span class="c1">; f) compare the current value with the min value recorded</span>
            <span class="c1">; [...]</span>

            <span class="c1">; c) increase the inner index and address</span>
            <span class="c1">; [...]</span>

        <span class="c1">; ----------------------------------------</span>
        <span class="c1">; g) swap the first value and the min value</span>
        <span class="c1">; [...]</span>

        <span class="c1">; d) increase the outer index and address</span>
        <span class="c1">; [...]</span>

    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>

    <span class="nf">ret</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can then complete the first initialization of the variables outside of the outer loops.
This will concern the function parameters and the index and address for the outer loop :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="c1">; a) first variable initialization</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">rdi</span> <span class="c1">; first parameter</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="nb">si</span> <span class="c1">; second parameter</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">],</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="mi">0</span> <span class="c1">; outer loop index</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nv">tbp</span><span class="o">-</span><span class="mi">22</span><span class="p">],</span> <span class="nb">rdi</span> <span class="c1">; array address for the outer loop</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can then put in place the iterations of the two loops by initializing the inner loop variables, increasing the indexes and addresses and testing for loop termination ( b, c, d) :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre><span class="c1">; ----------------------------------------</span>
<span class="c1">; outer loop</span>
<span class="nl">.L_outer_for:</span>

    <span class="c1">; b) init the inner array index and address</span>

    <span class="c1">; inner array index</span>
    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">14</span><span class="p">],</span> <span class="nb">ax</span>
    <span class="nf">inc</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span>

    <span class="c1">; inner array address</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">22</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">],</span> <span class="nb">rax</span>
    <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>

    <span class="c1">; e) init the temp value (current min) with the outer current element</span>

    <span class="c1">; ----------------------------------------</span>
    <span class="c1">; inner loop</span>
    <span class="nl">.L_inner_for:</span>

        <span class="c1">; f) compare the current value with the min value recorded</span>
        <span class="c1">; [...]</span>

        <span class="c1">; c) increase the inner index and address</span>
        <span class="nf">inc</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span>
        <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>

        <span class="c1">; compare then inner index with the array length</span>
        <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>
        <span class="nf">cmp</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span>
        <span class="nf">jne</span> <span class="nv">.L_inner_for</span>
 
    <span class="c1">; ----------------------------------------</span>
    <span class="c1">; g) swap the first value and the min value</span>
    <span class="c1">; [...]</span>

    <span class="c1">; d) increase the outer index and address</span>

    <span class="c1">; increase the outer index and address</span>
    <span class="nf">inc</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>
    <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">22</span><span class="p">]</span>

    <span class="c1">; compare the outer index with the array length</span>
    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>
    <span class="nf">inc</span> <span class="nb">ax</span>
    <span class="nf">cmp</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>
    <span class="nf">jne</span> <span class="nv">.L_outer_for</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>These loop controls are very similar to what we did previously.
Regarding the inner loop, the iteration starts from the array element that follows the one pointed to by the outer loop.
The sub array is then defined as all the remaining elements to the end of the array.</p>

<p>In this code, the indexes are tested at the end of the iterations and the loop termination occurs when they reach the end of the array.
You may notice that the outer index actually stops just before reaching the last element of the array (hence the <code class="language-plaintext highlighter-rouge">inc ax</code> operation).
Otherwise, the inner loop‚Äôs first iteration would go beyond the array bounds.</p>

<h4 id="comparing-and-swapping-elements">Comparing and swapping elements</h4>

<p>The central part of our algorithm will be the computation of the minimum values in the sub-arrays as we iterate in the inner loop.
To do so, we will use two variables to store respectively the array index of the current min and its value.</p>

<p>These variables can be initialized from the position of the outer array index (e) :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="c1">; e) init the temp value (current min) with the outer current element</span>

<span class="c1">; init the index of the current min value in the sub array</span>
<span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">],</span> <span class="nb">ax</span>

<span class="c1">; init the current min value to the element at the outer loop index</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">22</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">33</span><span class="p">],</span> <span class="nb">al</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We may note that as we already saw, two operations are necessary here to access an element of the array from its address.
First, the address is stored from the stock to a register.
Then, the value is taken at the address from the register and is stored in another register.
These two operations are necessary since two dereferences (namely taking the value stored at a given memory address) occur : one from the stack and another one from the array.</p>

<p>Then, at each inner loop iteration, it is necessary to compare the pointed value to the temporary minimum (f) :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="c1">; f) compare the current value with the min value recorded</span>

<span class="c1">; compare the two values</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span> <span class="c1">; inner array value</span>
<span class="nf">cmp</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">33</span><span class="p">]</span> <span class="c1">; current min value</span>
<span class="nf">jge</span> <span class="nv">.L_else_not_lower</span>

<span class="c1">; .L_if_lower update the min index       </span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>  
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>
    <span class="nf">Mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">33</span><span class="p">],</span> <span class="nb">al</span> <span class="c1">; store the current min in the temp variable</span>

    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">],</span> <span class="nb">ax</span> <span class="c1">; record the index </span>

<span class="nl">.L_else_not_lower:</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The first operations consist in comparing the value of the element at the inner loop index to the one temporarily stored as the minimum.
If the element is smaller, then the two corresponding variables are updated.
Otherwise, the program jumps to the following instructions (inverted if conditional).</p>

<p>We can now achieve the last part of the function : swapping the element at the outer index with the minimum element found in the sub-array (g);
In this operation, we will re-use two local variables that are no longer used at this point of the function.
The address of the inner loop element (<code class="language-plaintext highlighter-rouge">rbp-30</code>) will be used to store the address of the sub array min value.
The temp variable (<code class="language-plaintext highlighter-rouge">rbp-33</code>) will be used to store on of the value to swap the two elements  :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="c1">; g) swap the element at the outer loop index with the min value</span>

<span class="c1">; mov the address of the min element to the inner address variable</span>
<span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">add</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span>
<span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">],</span> <span class="nb">rax</span>

<span class="c1">; swap the values</span>

<span class="c1">; move the value at the outer address to the temp variable </span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">22</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">33</span><span class="p">],</span> <span class="nb">al</span> <span class="c1">; the outer element is stored in the temp variable</span>

<span class="c1">; move the min element value to the outer element's index </span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">22</span><span class="p">]</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">],</span> <span class="nb">al</span>

<span class="c1">; move the temp element (outer address) to the index of the min element</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">33</span><span class="p">]</span> <span class="c1">; get the temp value</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">],</span> <span class="nb">al</span> <span class="c1">; store it to the inner</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>And voil√†!
For each of these operations sub actions unfortunately, multiple assembly operations are necessary which makes the code less readable. 
I tried to partition the code as much as possible and decompose it into several simpler parts.</p>

<h4 id="final-function">Final function</h4>

<p>Here is the complete version of our <code class="language-plaintext highlighter-rouge">selection_sort</code> assembly function :</p>

<div class="collapse-panel"><div>
<label for="code_4">Expand</label>
<input type="checkbox" name="" id="code_4" /><span class="collapse-label"></span><div class="extensible-content">

<div class="code_frame"> Assembly x86-64 | selection_sort.s </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">selection_sort</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="c1">; Sort an array with the selection sort algorithm</span>
<span class="c1">; rdi : array pointer</span>
<span class="c1">; si : array length</span>
<span class="nl">selection_sort:</span>

    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">48</span> 
    <span class="c1">; rbp-8 : (8 bytes) array address (param)</span>
    <span class="c1">; rbp-10 : (2 bytes) array length (param)</span>
    <span class="c1">; rbp-12 : (2 bytes) outer index</span>
    <span class="c1">; rbp-14 : (2 bytes) inner index</span>
    <span class="c1">; rbp-22 : (8 bytes) outer array address</span>
    <span class="c1">; rbp-30 : (8 bytes) inner array address</span>
    <span class="c1">; rbp-32 : (2 bytes) sub-array min index</span>
    <span class="c1">; rbp-33 : (1 byte) temp value for swapping</span>

    <span class="c1">; variable initialization</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">rdi</span> <span class="c1">; array address</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="nb">si</span> <span class="c1">; array length</span>
    
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">],</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="mi">0</span> <span class="c1">; init the outer array index</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">22</span><span class="p">],</span> <span class="nb">rdi</span> <span class="c1">; init the outer array address</span>

    <span class="c1">; ----------------------------------------</span>
    <span class="c1">; outer loop</span>
    <span class="nl">.L_outer_for:</span>

        <span class="c1">; init the inner array index &lt;- array_index+1</span>
        <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">14</span><span class="p">],</span> <span class="nb">ax</span>
        <span class="nf">inc</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span>
        

        <span class="c1">; init the sub-array min index</span>
        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">],</span> <span class="nb">ax</span>

        <span class="c1">; init the inner array address</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">22</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">],</span> <span class="nb">rax</span>
        <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>

        <span class="c1">; init the temp value (current min) with the outer current element</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">22</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">33</span><span class="p">],</span> <span class="nb">al</span>

        <span class="c1">; ----------------------------------------</span>
        <span class="c1">; inner loop</span>
        <span class="nl">.L_inner_for:</span>

            <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>
            <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span> <span class="c1">; inner array value</span>

            <span class="nf">cmp</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">33</span><span class="p">]</span> <span class="c1">; current min value</span>
            
            <span class="nf">jge</span> <span class="nv">.L_else_not_lower</span>

            <span class="c1">; .L_if_lower update the min index</span>
                
                <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>  
                <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>
                <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">33</span><span class="p">],</span> <span class="nb">al</span> <span class="c1">; store the current min in the temp variable</span>

                <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span>
                <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">],</span> <span class="nb">ax</span> <span class="c1">; record the index </span>

            <span class="nl">.L_else_not_lower:</span>

            <span class="c1">; increase the inner address</span>
            <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>

            <span class="c1">; increase the inner index and compare with the array length</span>
            <span class="nf">inc</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span>
            <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>
            <span class="nf">cmp</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span>
            <span class="nf">jne</span> <span class="nv">.L_inner_for</span>

        <span class="c1">; ----------------------------------------</span>
        <span class="c1">; swap the values</span>

        <span class="c1">; move the address of the min element in the inner address variable</span>
        <span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
        <span class="nf">add</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span>
        <span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">],</span> <span class="nb">rax</span>

        <span class="c1">; move the value at the outer address to the temp variable </span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">22</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">33</span><span class="p">],</span> <span class="nb">al</span> <span class="c1">; the outer element is stored in the temp variable</span>

        <span class="c1">; swap the values</span>
        
        <span class="c1">; min value to outer element's index</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">22</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">],</span> <span class="nb">al</span>

        <span class="c1">; temp value to the min element's index</span>
        <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">33</span><span class="p">]</span> <span class="c1">; get the temp value</span>
        <span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">30</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">],</span> <span class="nb">al</span> <span class="c1">; store it to the inner</span>
         

        <span class="c1">; increase the outer address</span>
        <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">22</span><span class="p">]</span>

        <span class="c1">; increase the outer index and compare with the array length</span>
        <span class="nf">inc</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>
        <span class="nf">inc</span> <span class="nb">ax</span>
        <span class="nf">cmp</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>
        <span class="nf">jne</span> <span class="nv">.L_outer_for</span>

    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>

    <span class="nf">ret</span>
</pre></td></tr></tbody></table></code></pre></figure>

</div></div></div>

<p>You should be able to call the function from the main function on the array stored on the stack and observe such result :</p>

<div class="code_frame"> Bash | main's output </div>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre>My array :        5 12 42 8 1 3 7 25 14 
My array sorted : 1 3 5 7 8 12 14 25 42
</pre></td></tr></tbody></table></code></pre></figure>

<p>Yeee!! üî•</p>

<p>This version of the selection sort is actually quite long.
One possibility to improve it is to perform the swap in the inner loop, although it would be a little bit less efficient.
I encourage you to find possible variations in order to make it as clean as possible.</p>

<h2 id="whats-next-">What‚Äôs next ?</h2>

<p>I would congratulate you if you made it this far!
Although this part was more about assembling all the previous notions to solve a concrete problem, it has the advantage to make us develop a organization and abstraction abilities in order to navigate in this nonsense-of-a-code.</p>

<p>You will find the codes from this part at the following <a href="https://github.com/smbct/x86-64_101_linux/tree/main/pt6_sorting">address</a>.
I will probably write an addition last part to this series in order to produce a more visual program!
This will however not necessarily be the end of the posts or series about assembly as I have multiple ideas of how to make apply such knowledge on concrete problems.</p>


    



<div class="post-tags">
  
</div>
  </div>

  

  
  <section class="comments">
    <!-- <h2>Comments</h2> -->
    <script src="https://giscus.app/client.js"
        data-repo="smbct/smbct.github.io"
        data-repo-id="R_kgDOL0ffhg"
        data-category="Announcements"
        data-category-id="DIC_kwDOL0ffhs4CfYJ5"
        data-mapping="title"
        data-strict="1"
        data-reactions-enabled="0"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
  </script>

  </section>


</div>




<p class="back-link">
    <a href="/series/x86_64_assembly/headline.html"><span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>Assembly x86 programming 101</a>
</p>


    </main>

    <!-- Optional footer content -->

  </body>
</html>
