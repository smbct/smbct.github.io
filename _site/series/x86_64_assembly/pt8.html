<!DOCTYPE html>
<html lang="en">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  

  <title>
    
      Assembly x86 programming 101 &#58 chapter 8, graphical Mandelbrot &middot; smbct's blog
    
  </title>

  <!-- 
 -->

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="series_article">

    
    <div id="sidebar">
  <header>
    <div class="site-title">
      <a href="/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        smbct's blog
      </a>
    </div>
    <p class="lead">Notes on computer science, society and more.</p>
  </header>
  <nav id="sidebar-nav-links">

  
    
      <a class="home-link "
          href="/">Blog</a>
    
  
  
  

  

  


  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  



  <!-- should be improved -->
  
  <a class="category-link "
          href="/pages/series.html">Series </a>
  

  


  
    
  

  
    
      <a class="category-link "
          href="/pages/about.html">About</a>
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">

  <a id="subscribe-link" class="icon" title="Subscribe" aria-label="Subscribe"
    href="/feed.xml">
    <svg fill="#000000" height="26" viewBox="0 0 24 24" width="26" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>

  </a>

  <a id="mastodon-link" class="icon" title="Mastodon" aria-label="Mastodon"
    href="https://social.linux.pizza/@smbct">
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" class="bi bi-mastodon" viewBox="0 0 16 16">
  <path d="M11.19 12.195c2.016-.24 3.77-1.475 3.99-2.603.348-1.778.32-4.339.32-4.339 0-3.47-2.286-4.488-2.286-4.488C12.062.238 10.083.017 8.027 0h-.05C5.92.017 3.942.238 2.79.765c0 0-2.285 1.017-2.285 4.488l-.002.662c-.004.64-.007 1.35.011 2.091.083 3.394.626 6.74 3.78 7.57 1.454.383 2.703.463 3.709.408 1.823-.1 2.847-.647 2.847-.647l-.06-1.317s-1.303.41-2.767.36c-1.45-.05-2.98-.156-3.215-1.928a4 4 0 0 1-.033-.496s1.424.346 3.228.428c1.103.05 2.137-.064 3.188-.189zm1.613-2.47H11.13v-4.08c0-.859-.364-1.295-1.091-1.295-.804 0-1.207.517-1.207 1.541v2.233H7.168V5.89c0-1.024-.403-1.541-1.207-1.541-.727 0-1.091.436-1.091 1.296v4.079H3.197V5.522q0-1.288.66-2.046c.456-.505 1.052-.764 1.793-.764.856 0 1.504.328 1.933.983L8 4.39l.417-.695c.429-.655 1.077-.983 1.934-.983.74 0 1.336.259 1.791.764q.662.757.661 2.046z"/>
</svg>

  </a>

  
    <a id="github-link"
       class="icon" title="Github Profile" aria-label="Github Profile"
       href="https://github.com/smbct">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 28" height="22" width="22"><path d="M12 2c6.625 0 12 5.375 12 12 0 5.297-3.437 9.797-8.203 11.391-0.609 0.109-0.828-0.266-0.828-0.578 0-0.391 0.016-1.687 0.016-3.297 0-1.125-0.375-1.844-0.812-2.219 2.672-0.297 5.484-1.313 5.484-5.922 0-1.313-0.469-2.375-1.234-3.219 0.125-0.313 0.531-1.531-0.125-3.187-1-0.313-3.297 1.234-3.297 1.234-0.953-0.266-1.984-0.406-3-0.406s-2.047 0.141-3 0.406c0 0-2.297-1.547-3.297-1.234-0.656 1.656-0.25 2.875-0.125 3.187-0.766 0.844-1.234 1.906-1.234 3.219 0 4.594 2.797 5.625 5.469 5.922-0.344 0.313-0.656 0.844-0.766 1.609-0.688 0.313-2.438 0.844-3.484-1-0.656-1.141-1.844-1.234-1.844-1.234-1.172-0.016-0.078 0.734-0.078 0.734 0.781 0.359 1.328 1.75 1.328 1.75 0.703 2.141 4.047 1.422 4.047 1.422 0 1 0.016 1.937 0.016 2.234 0 0.313-0.219 0.688-0.828 0.578-4.766-1.594-8.203-6.094-8.203-11.391 0-6.625 5.375-12 12-12zM4.547 19.234c0.031-0.063-0.016-0.141-0.109-0.187-0.094-0.031-0.172-0.016-0.203 0.031-0.031 0.063 0.016 0.141 0.109 0.187 0.078 0.047 0.172 0.031 0.203-0.031zM5.031 19.766c0.063-0.047 0.047-0.156-0.031-0.25-0.078-0.078-0.187-0.109-0.25-0.047-0.063 0.047-0.047 0.156 0.031 0.25 0.078 0.078 0.187 0.109 0.25 0.047zM5.5 20.469c0.078-0.063 0.078-0.187 0-0.297-0.063-0.109-0.187-0.156-0.266-0.094-0.078 0.047-0.078 0.172 0 0.281s0.203 0.156 0.266 0.109zM6.156 21.125c0.063-0.063 0.031-0.203-0.063-0.297-0.109-0.109-0.25-0.125-0.313-0.047-0.078 0.063-0.047 0.203 0.063 0.297 0.109 0.109 0.25 0.125 0.313 0.047zM7.047 21.516c0.031-0.094-0.063-0.203-0.203-0.25-0.125-0.031-0.266 0.016-0.297 0.109s0.063 0.203 0.203 0.234c0.125 0.047 0.266 0 0.297-0.094zM8.031 21.594c0-0.109-0.125-0.187-0.266-0.172-0.141 0-0.25 0.078-0.25 0.172 0 0.109 0.109 0.187 0.266 0.172 0.141 0 0.25-0.078 0.25-0.172zM8.937 21.438c-0.016-0.094-0.141-0.156-0.281-0.141-0.141 0.031-0.234 0.125-0.219 0.234 0.016 0.094 0.141 0.156 0.281 0.125s0.234-0.125 0.219-0.219z"></path>
</svg>

    </a>
  

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/tags.html">
      <svg fill="#000000" height="26" viewBox="0 0 24 24" width="26" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>

    </a>
  

  

  <!-- Optional additional links to insert for icons links -->




<!-- index pages are treated separately to handle pagination -->


<!-- for other pages, the link to the translated page is in a file -->


<!-- When one of the link is not set, the corresponding flag cannot be clicked -->

<a id="icon_flag"
     class="icon_flag active"
     
     >
üá¨üáß <div></div>
</a>
<a id="icon_flag"
  class="icon_flag"
  
>
üá´üá∑ <div></div>
</a>



</nav>

  <p>
  &copy; 2025.
  <a href="/LICENSE.md">MIT License.</a>
</p>

</div>
    

    <main class="container">
      <header>
  


<p class="back-link">
    <a href="/series/x86_64_assembly/headline.html"><span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>Assembly x86-64 programming 101</a>
</p>


  <h1 class="post-title">Assembly x86 programming 101 &#58 chapter 8, graphical Mandelbrot</h1>
</header>
<div class="content">
  <div class="post-meta">
  
  <!-- Thanks to https://stackoverflow.com/questions/10714980/locale-specific-date-in-jekyll -->
  <span class="post-date">
    üìÖ
    
      06 Aug 2024
    
  </span>

  ‚Ä¢ ‚è≤Ô∏è
  <!-- taken from https://carlosbecker.com/posts/jekyll-reading-time-without-plugins/ -->

<span class="reading-time" title="Estimated read time">
  
  
    32 
    
      mins
    
  
</span>
  ‚Ä¢
  
  üá¨üáß
  

  <span class="post-categories">
    
      &bull;

      
      
      

      
        low-level programming assembly
      
    
  </span>
</div>



  <div class="post-body">
    <p>In the previous chapter, we saw the use of vector registers in assembly to perform floating point operations on decimal numbers.
Although the result was already interesting, still it is a shame that a wonderfull object such as the Mandelbrot set cannot be visualized under its best angle.</p>

<p>In this chapter, we will build from this previous code and bring it to a new dimension by using a graphical library üìä.
This will allow us to see how such library üìö can be <strong>linked</strong> üîó to our program and how to <strong>call its functions</strong> üì£ directly from our assembly program.</p>

<h2 id="setting-up-a-graphical-library-from-x86-64">Setting up a graphical library from x86-64</h2>

<p>Our first step is to pick an appropriate library for our project.
This idea led me directly to the <a href="http://127.0.0.1:4000/series/x86_64_assembly/pt8">Simple and Fast Multimedia Library (SFML)</a>.
This library offers numerous functionalities to build graphical applications with hardware acceleration, support for audio üéß and networking üõú, etc.. while being extremely easy to use.
The SFML library is coded in C++ but we will actually not rely on its native version in our program.</p>

<p><img src="/assets/assembly_series/sfml_logo.png" alt="TheSFML logo" /></p>
<div class="custom_caption">
  <p>&gt; The SFML logo.</p>
</div>

<h4 id="whats-wrong-with-c-">What‚Äôs wrong with C++ ?</h4>

<p>I will be honest, it took me some time to make this chapter work properly.
The natural choice to interface SFML with our program was to use its C++ API.
However, it turns out to be quite delicate üòµ‚Äçüí´ for several reasons.</p>

<p>We already saw in the <a href="pt6">5th chapter</a> how to call a function from a C compiled ‚öôÔ∏è program in our assembly code.
To do so, our compiled code (object file) just needed to be linked üîó to the compiled C code, and we were able to call üì£ our the function without any additional definition.
This changes a little bit in C++ as some code is generated from the header files (function definitions, templated functions, etc..).
This code is however only generated to produce a final executable and I was not able ‚ùå to obtain a compiled version of all the interface functions of the library.</p>

<p>C is on the other hand a much simpler language where object files contain everything that is needed to call a library‚Äôs <a href="https://en.wikipedia.org/wiki/API">API</a>.
This is why a finally decided to rely on the <a href="https://www.sfml-dev.org/download/csfml/">C SFML binding</a> for this chapter (note üìù that it is possible to create C bindings from any C++ library).
C seems stable enough so that the binding is actually chosen instead of the native C++ API as basis of othe bindings such as the <a href="https://www.sfml-dev.org/download/sfml.net/">.NET</a> or the <a href="https://github.com/jeremyletang/rust-sfml">Rust</a> ones. Quoting from the .NET bind page :</p>
<blockquote>
  <p>It is built on top of the C binding, CSFML, to ensure maximum compatibility across platforms.</p>
</blockquote>

<h2 id="our-first-x86-sfml-program">Our first x86-SFML program</h2>

<p>We will start by setting up our project to develop with the C-SFML library.
The first step consists in downloading the C-SFML sources from the official <a href="https://www.sfml-dev.org/download/csfml/">page</a> (there is no compiled release for Linux at the moment).
There is no need to download üõú the original C++ SFML library as the CSFML binding already contains these sources.
<a href="https://cmake.org/">CMake</a> will then allow to compile the sources and install the binaries on your system.</p>

<h4 id="project-configuration">Project configuration</h4>

<p>We will start with a simple main function in x86 assembly.
We rely on the <code class="language-plaintext highlighter-rouge">libc</code> main function in order to allow the use of the C standard library in our program with useful functions such as <code class="language-plaintext highlighter-rouge">printf</code>.</p>

<div class="collapse-panel"><div>
<label for="code_1">Expand</label>
<input type="checkbox" name="" id="code_1" /><span class="collapse-label"></span>
<div class="extensible-content">
<div class="code_frame">hello_sfml.s | Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">main</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="nl">main:</span>
    
    <span class="nf">push</span> <span class="nb">rbp</span> <span class="c1">; storing the rbp value before manipulation</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span> <span class="c1">; storing the rsp register</span>

    <span class="c1">; storing the preserved registers</span>
    <span class="nf">push</span> <span class="nb">rdi</span>
    <span class="nf">push</span> <span class="nb">rsi</span>

    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">hello_world</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">14</span>
    <span class="nf">syscall</span>

    <span class="nf">pop</span> <span class="nb">rsi</span>
    <span class="nf">pop</span> <span class="nb">rdi</span>

    <span class="c1">; restoring the rsp and rbp registers</span>
    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>

    <span class="c1">; return</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">ret</span>

<span class="nl">hello_world:</span>
    <span class="nf">.asciz</span> <span class="err">"</span><span class="nv">Hello</span><span class="p">,</span> <span class="nv">World</span><span class="err">!\</span><span class="nv">n</span><span class="err">"</span>
</pre></td></tr></tbody></table></code></pre></figure>

</div></div></div>

<p>The compilation will be performed in two steps as we already did in previous chapters : first compiling (more accurately assembling) the x86 source files into object files, and second linking the object files together with the additional external libraries üìö.</p>

<p>We will create a Makefile to simplify the use of long compilation commands here.
The makefile will contain only 2 lines :</p>

<div class="code_frame">Makefile</div>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="nl">hello_sfml</span><span class="o">:</span> <span class="nf">hello_sfml.o</span>
	gcc hello_sfml.o <span class="nt">-lcsfml-graphics</span> <span class="nt">-lcsfml-window</span> <span class="nt">-lcsfml-system</span> <span class="nt">-o</span> hello_sfml

<span class="nl">hello_sfml.o</span><span class="o">:</span> <span class="nf">hello_sfml.s</span>
	as hello_sfml.s <span class="nt">-c</span> <span class="nt">-o</span> hello_sfml.o
</pre></td></tr></tbody></table></code></pre></figure>

<p>The main new thing in our linking command is the C-SFML shared library files for the  <code class="language-plaintext highlighter-rouge">graphics</code>, <code class="language-plaintext highlighter-rouge">window</code> and <code class="language-plaintext highlighter-rouge">system</code> <a href="https://www.sfml-dev.org/index.php">modules</a> respectively.</p>

<p>You could also notice that here we omitted the <code class="language-plaintext highlighter-rouge">-static</code> options we used in the previous chapters.
This is because now we are working with a <a href="https://en.wikipedia.org/wiki/Shared_library">shared library</a>.
This means that the C-SFML object code will not be incorporated in the final executable of our program but will be loaded at runtime instead.</p>

<p>Let‚Äôs now try to compile our program thanks to our Makefile with the <code class="language-plaintext highlighter-rouge">make</code> command:</p>

<div class="code_frame">Bash</div>

<figure class="highlight"><pre><code class="language-plain" data-lang="plain"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre>&gt; make hello_sfml
as -g hello_sfml.s -c -o hello_sfml.o
gcc hello_sfml.o -lcsfml-graphics -lcsfml-window -lcsfml-system -o hello_sfml
/usr/bin/ld: hello_sfml.o: relocation R_X86_64_32S against `.text' can not be used when making a PIE object; recompile with -fPIE
/usr/bin/ld¬†: impossible de fixer les tailles des sections dynamiques¬†: bad value
collect2: error: ld returned 1 exit status
make: *** [Makefile:48 : hello_sfml] Erreur 1
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can see üßê that removing the <code class="language-plaintext highlighter-rouge">-static</code> option from our linking command ‚õìÔ∏è actually introduced an error üö´.
The linker (<code class="language-plaintext highlighter-rouge">ld</code>) complains because we are making a <strong>PIE</strong> file, namely a <strong>P</strong>osition <strong>I</strong>ndependant <strong>E</strong>xecutable.
Indeed, adding a <strong>shared library</strong> to our program implies that it will references additional compiled code (from the library) during its execution.
For this reason, all the references (or line numbers) in our code must be <strong>relative</strong> to the current instruction (that is stored in the <code class="language-plaintext highlighter-rouge">rip</code> register).</p>

<p>A simple fix to make our program compile ‚úÖ as a PIE executable consists in specifying the <code class="language-plaintext highlighter-rouge">rip</code> register werether a data label is referenced in the code.
Here, this only happens when referencing our <em>‚ÄúHello, World!\n‚Äù</em> string, at line 15.</p>

<p>Our code should then become :</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">hello_world</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This way, the asembler will know we that we are creating a Position Independent Executable, where references are relatives to the pointed instruction.
The code should now compile ‚öôÔ∏è with the <code class="language-plaintext highlighter-rouge">make</code> command.</p>

<h2 id="opening-a-window-in-csfml">Opening a window in CSFML</h2>

<p>We can now start calling SFML functions through its C API.
Our first goal will be to create and open a new window ü™ü.</p>

<h4 id="opening-a-window-in-c-with-csfml">Opening a window in C with CSFML</h4>

<p>A simple way to start our implementation consists in first creating a C code that creates a window ü™ü in SFML and then using GCC to create assembly from this code and analyse how the functions are called.
This is in fact similar to what we did in <a href="pt7#how-are-floats-implemented-in-c-">chapter 7</a> to see how floating point operations were performed.
Our basis will be the follwing code :</p>

<div class="code_frame">C | create_window_c.c </div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;SFML/Graphics.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

    <span class="k">const</span> <span class="n">sfVideoMode</span> <span class="n">mode</span> <span class="o">=</span> <span class="p">{</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">32</span><span class="p">};</span>

    <span class="c1">// create the main window</span>
    <span class="n">sfRenderWindow</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="n">sfRenderWindow_create</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s">"SFML window"</span><span class="p">,</span> <span class="n">sfResize</span> <span class="o">|</span> <span class="n">sfClose</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// display the window</span>
    <span class="n">sfRenderWindow_display</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

    <span class="c1">// pause</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    
    <span class="c1">// destroy the window</span>
    <span class="n">sfRenderWindow_destroy</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>You can see that this program simply creates a window ‚Äúobject‚Äù (data <strong>struct</strong>ure) by calling the <code class="language-plaintext highlighter-rouge">sfRenderWindow_create</code> function.
The window is then displayed followed by a pause to actually see the window.
After that, the window object is cleaned up using a destroy function.
The C API of the SFML library will always follow this scheme : the data of a C++ object is encapsulated in a <code class="language-plaintext highlighter-rouge">struct</code>, and dedicated functions allow the user to interact with it, including mermory allocating and de-allocating the object.</p>

<p>The following two lines in our Makefile will allow to test the code :</p>

<div class="code_frame">Makefile</div>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="nl">create_window_c.o</span><span class="o">:</span> <span class="nf">create_window_c.c</span>
	gcc create_window_c.c <span class="nt">-c</span> <span class="nt">-o</span> create_window_c.o

<span class="nl">create_window_c</span><span class="o">:</span> <span class="nf">create_window_c.o</span>
	gcc create_window_c.o <span class="nt">-lcsfml-graphics</span> <span class="nt">-lcsfml-window</span> <span class="nt">-lcsfml-system</span> <span class="nt">-o</span> create_window_c
</pre></td></tr></tbody></table></code></pre></figure>

<p>Now before compiling this code into assembly, we need to perform some refactoring in order to simplify the task of calling the library üìö from assembly.
Indeed, in the above C code, the problem is that values are directly  given in the function call without defining a proper variable with the corresponding data type.
This makes the code more difficult to read üëì since we should be able to understand precisely how the data structures are defined and what memory to allocate.</p>

<p>Here is the actual definition of the <code class="language-plaintext highlighter-rouge">sfRenderWindow_create</code> function, directly taken from the header file :</p>

<div class="code_frame">C | RenderWindow.h </div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">CSFML_GRAPHICS_API</span> <span class="n">sfRenderWindow</span><span class="o">*</span> <span class="nf">sfRenderWindow_create</span><span class="p">(</span><span class="n">sfVideoMode</span> <span class="n">mode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">title</span><span class="p">,</span> <span class="n">sfUint32</span> <span class="n">style</span><span class="p">,</span> <span class="k">const</span> <span class="n">sfContextSettings</span><span class="o">*</span> <span class="n">settings</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Let‚Äôs now refactor our previous code by explicitely creating variables for all the arguments :</p>

<div class="code_frame">C | create_window_c.c </div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="c1">// [...]</span>

<span class="c1">// window pointer</span>
<span class="n">sfRenderWindow</span><span class="o">*</span> <span class="n">window</span><span class="p">;</span>

<span class="c1">// window arguments</span>
<span class="k">const</span> <span class="n">sfVideoMode</span> <span class="n">mode</span> <span class="o">=</span> <span class="p">{</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">32</span><span class="p">};</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">title</span> <span class="o">=</span> <span class="s">"SFML window"</span><span class="p">;</span>
<span class="n">sfUint32</span> <span class="n">style</span> <span class="o">=</span> <span class="n">sfResize</span> <span class="o">|</span> <span class="n">sfClose</span><span class="p">;</span>
<span class="k">const</span> <span class="n">sfContextSettings</span><span class="o">*</span> <span class="n">settings</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="c1">// create the main window</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">sfRenderWindow_create</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">sfResize</span> <span class="o">|</span> <span class="n">sfClose</span><span class="p">,</span> <span class="n">settings</span><span class="p">);</span>

<span class="c1">// [...]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The code should function exactly as previously, except that now we can explicitly see üëÄ what data is allocated in order to pass the parameters.</p>

<h4 id="opening-a-window-from-assembly">Opening a window from assembly</h4>

<p>Let‚Äôs add a new entry in our Makefile to transform our previous code into assembly :</p>

<div class="code_frame">Makefile</div>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nl">create_window_c.s</span><span class="o">:</span> <span class="nf">create_window_c.c</span>
	gcc <span class="nt">-S</span> create_window_c.c <span class="nt">-masm</span><span class="o">=</span>intel <span class="nt">-fdiagnostics-color</span><span class="o">=</span>always <span class="nt">-fverbose-asm</span> <span class="nt">-o</span> create_window_c.s
</pre></td></tr></tbody></table></code></pre></figure>

<p>For now, let‚Äôs extract the portion responsible of allocating the window ü™ü structure :</p>

<div class="code_frame">Assembly x86-64 | create_window_c.s </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="c1">; create_window_c.c:12:     const char* title = "SFML window";</span>
	<span class="nf">lea</span>	<span class="nb">rax</span><span class="p">,</span> <span class="nv">.LC0</span><span class="p">[</span><span class="nv">rip</span><span class="p">]</span>	<span class="c1">; tmp84,</span>
	<span class="nf">mov</span>	<span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">24</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nb">rax</span>	<span class="c1">; title, tmp84</span>
<span class="c1">; create_window_c.c:13:     sfUint32 style = sfResize | sfClose;</span>
	<span class="nf">mov</span>	<span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">28</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="mi">6</span>	<span class="c1">; style,</span>
<span class="c1">; create_window_c.c:14:     const sfContextSettings* settings = NULL;</span>
	<span class="nf">mov</span>	<span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">16</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="mi">0</span>	<span class="c1">; settings,</span>
<span class="c1">; create_window_c.c:17:     window = sfRenderWindow_create(mode, title, sfResize | sfClose, settings);</span>
	<span class="nf">mov</span>	<span class="nb">rcx</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">16</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp85, settings</span>
	<span class="nf">mov</span>	<span class="nb">rdx</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">24</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp86, title</span>
	<span class="nf">mov</span>	<span class="nb">rsi</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="nv">mode.0</span><span class="p">[</span><span class="nv">rip</span><span class="p">]</span>	<span class="c1">; tmp87, mode</span>
	<span class="nf">mov</span>	<span class="nb">eax</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="nv">mode.0</span><span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>	<span class="c1">; tmp88, mode</span>
	<span class="nf">mov</span>	<span class="nv">r8</span><span class="p">,</span> <span class="nb">rcx</span>	<span class="c1">;, tmp85</span>
	<span class="nf">mov</span>	<span class="nb">ecx</span><span class="p">,</span> <span class="mi">5</span>	<span class="c1">;,</span>
	<span class="nf">mov</span>	<span class="nb">rdi</span><span class="p">,</span> <span class="nb">rsi</span>	<span class="c1">;, tmp87</span>
	<span class="nf">mov</span>	<span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>	<span class="c1">;, tmp88</span>
	<span class="nf">call</span>	<span class="nv">sfRenderWindow_create@PLT</span>	<span class="c1">;</span>
	<span class="nf">mov</span>	<span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">8</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nb">rax</span>	<span class="c1">; window, tmp89</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The arguments of the <code class="language-plaintext highlighter-rouge">sfRenderWindow_create</code> function are of multiple types.
<code class="language-plaintext highlighter-rouge">mode</code> is a <code class="language-plaintext highlighter-rouge">sfVideoMode</code> <strong>struct</strong>ure (as we can see from the definition), title is a <strong>char array</strong>, style is a <strong>32 bits integer</strong> and settings is a <strong>pointer</strong>.</p>

<ul>
  <li>
    <p>The ‚Äúsettings‚Äù argument is the easyest to start with.
Indeed, although this argument is a pointer ‚û°Ô∏è, the default value <code class="language-plaintext highlighter-rouge">NULL</code> is used in our code.
Since pointers are just addresses, and since addresses are coded on <strong>8 bytes</strong>, the value that will be given to the function will simply be a <em>0</em> coded on 8 bytes.
This can be seen at lines <em>7</em> and <em>9</em> from the code above.</p>
  </li>
  <li>
    <p>The ‚Äútitle‚Äù argument is also an easy one to specify.
Indeed, we already saw in the previous chapters how to manipulate arrays of characters in assembly.
We can see at lines <em>2</em> and <em>3</em> that the string ‚õìÔ∏è is defined at the <code class="language-plaintext highlighter-rouge">.LC0</code> symbol in the code and its address is the stored in the stack ü•û.
We can omit the stack part in our code as it is possible to directly reference the address of the symbol in the program‚Äôs memory.</p>
  </li>
  <li>
    <p>We saw that the ‚Äústyle‚Äù argument is a simple integer. Howether, its value is obtained through <em><a href="https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/">bitwise</a></em> operators, which is a way to store several values into a unique variable.
We can see at lines <em>4</em> and <em>5</em> that the resulting value of the combined flags <code class="language-plaintext highlighter-rouge">sfResize | sfClose</code> is actually <strong>6</strong>. In our case, we can directly use this raw value in the code to simplify things.</p>
  </li>
  <li>
    <p>The last parameter, ‚Äúmode‚Äù, has the type <code class="language-plaintext highlighter-rouge">sfVideoMode</code>, which is a structure with 4 integers.
We can see at lines <em>11</em> and <em>12</em> that its value is defined at symbol <code class="language-plaintext highlighter-rouge">mode.0</code>, that is :</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="nl">mode.0:</span>
<span class="c1">; width:</span>
	<span class="nf">.long</span>	<span class="mi">800</span>
<span class="c1">; height:</span>
	<span class="nf">.long</span>	<span class="mi">600</span>
<span class="c1">; bitsPerPixel:</span>
	<span class="nf">.long</span>	<span class="mi">32</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Since data values of a <strong>struct</strong> are contiguous in memory, this order will actually always be verified when defining a <code class="language-plaintext highlighter-rouge">sfVideoMode</code>.
We can see that the <em>3</em> values are coded on <strong>4</strong> bytes each (<code class="language-plaintext highlighter-rouge">.long</code>).
This implies that 12 bytes of memory are necessary to pass all the values.
This is the reason why this parameter is splitted across two registers, <code class="language-plaintext highlighter-rouge">rdi</code> that contains the width and height values contiguously (lines <em>11</em> and <em>15</em>) and <code class="language-plaintext highlighter-rouge">esi</code> that contains the ‚ÄúbitsPerPixel‚Äù field on 4 bytes (lines <em>12</em> and <em>16</em>).</p>

<p>We can now write our own assembly code to open the window, starting from the following basis :</p>

<div class="code_frame">create_window_assembly.s | Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">main</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="nl">main:</span>
    
    <span class="nf">push</span> <span class="nb">rbp</span> <span class="c1">; storing the rbp value before manipulation</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span> <span class="c1">; storing the rsp register</span>

    <span class="c1">; memory allocation (window pointer)</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">8</span>

    <span class="c1">; storing the preserved registers</span>
    <span class="nf">push</span> <span class="nb">rdi</span>
    <span class="nf">push</span> <span class="nb">rsi</span>
    <span class="nf">push</span> <span class="nb">rbx</span>

    <span class="c1">; window creation</span>
    <span class="c1">; [...]</span>

    <span class="c1">; calling "display"</span>
    <span class="c1">; [...]</span>

    <span class="c1">; calling "sleep"</span>
    <span class="c1">; [...]</span>

    <span class="c1">; window destruction</span>
    <span class="c1">; [...]</span>

    <span class="nf">pop</span> <span class="nb">rbx</span>
    <span class="nf">pop</span> <span class="nb">rsi</span>
    <span class="nf">pop</span> <span class="nb">rdi</span>

    <span class="c1">; restoring the rsp and rbp registers</span>
    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>

    <span class="c1">; return</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">ret</span>

<span class="c1">; constants definitions</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Note üìù that 8 bytes are allocated in the stack ü•û as we need to store üóÑÔ∏è the window pointer (returned by the ‚Äúcreate‚Äù function).
We then start completing by defining the constants : the video mode, the window title and the style :</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="c1">; constants definitions</span>
<span class="nl">window_title:</span>
   <span class="nf">.string</span>	<span class="err">"</span><span class="nv">SFML</span> <span class="nv">x86</span> <span class="nv">window</span><span class="err">"</span>

<span class="c1">; window video mode</span>
<span class="nl">window_width:</span>
    <span class="nf">.long</span> <span class="mi">800</span>
<span class="nl">window_height:</span>
    <span class="nf">.long</span> <span class="mi">600</span>
<span class="nl">window_depth:</span>
    <span class="nf">.long</span> <span class="mi">32</span>

<span class="c1">; window style (sfResize | sfClose)</span>
<span class="nl">window_style:</span>
    <span class="nf">.long</span> <span class="mi">6</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Now we can complete the code by calling the ‚Äúcreate‚Äù function. Recall that the order of the registers for the parameters are given in this <a href="https://i.sstatic.net/j8hpC.png">table</a> (see <a href="pt5">chapter 5</a>).</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="c1">; window creation</span>
<span class="c1">; video mode</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">window_width</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">window_depth</span><span class="p">]</span>
<span class="c1">; title</span>
<span class="nf">lea</span> <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">window_title</span><span class="p">]</span>
<span class="c1">; style</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">window_style</span><span class="p">]</span>
<span class="c1">; settings</span>
<span class="nf">mov</span> <span class="nv">r8</span><span class="p">,</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="mi">0</span>
<span class="nf">call</span> <span class="nv">sfRenderWindow_create</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">rax</span> <span class="c1">; store the window ptr</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Moreover, it is now also necessary to specify the <code class="language-plaintext highlighter-rouge">rip</code> register as we are creating a <strong>PIE</strong> and it is not necessary to provide any definition of the library functions to our code, contrary to other languages such as C or C++ as we saw in <a href="pt5#calling-a-custom-c-function">chapter 5</a>.</p>

<p>We can now add the other function calls, that are much simpler in terms of arguments :</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="c1">; calling "display"</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">call</span> <span class="nv">sfRenderWindow_display</span>

<span class="c1">; calling "sleep"</span>
<span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="mi">5</span>
<span class="nf">call</span> <span class="nv">sleep</span>

<span class="c1">; window destruction</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">call</span> <span class="nv">sfRenderWindow_destroy</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can see that the two other CSFML functions have only one argument which is the address of the window object ü™ü (pointer), and do not return anything.
The complete code can be compiled with a Makefile entry similar to the one from our previous CSFML ‚Äúhello world‚Äù.
It should now function exactly as the analog C program.</p>

<h2 id="graphical-mandelbrot">Graphical Mandelbrot</h2>

<p>As we can now display an SFML window ü™ü from assembly, it is time to actually draw the Mandelbrot set üñçÔ∏è!
We will first see how to draw pixel per pixel in an image and display the result on the window.</p>

<h4 id="drawing-in-sfml">Drawing in SFML</h4>

<p>Although providing a complete tutorial on SFML is not the goal of this chapter, it is still important to see how drawing üëæ works in this library üìù.
We actually need to manipulate 3 different type of objects in our code in order to achieve the drawing.</p>

<ul>
  <li>
    <p>The first object type is <code class="language-plaintext highlighter-rouge">sfImage</code>.
It allows to store and manipulate an array of pixel.</p>
  </li>
  <li>
    <p>The second one is <code class="language-plaintext highlighter-rouge">sfTexture</code>. It is also used to store pixels but this object is actually stored on the graphics card side, in order to speed up the display üñ•Ô∏è.</p>
  </li>
  <li>
    <p>The third oblect to manipulate is <code class="language-plaintext highlighter-rouge">sfSprite</code>. Although the <code class="language-plaintext highlighter-rouge">sfTexture</code> object already prepare an image to be displayed on the screen by the hardware, it is still necessary to provide additional options such as its coordinates and its rotation.
This type is used to store these information so that several graphical object with the same texture can be manipulated sepatately.</p>
  </li>
</ul>

<p><img src="https://icon.ink/wp-content/uploads/sites/5/2020/07/super-mario-world-screenshot-215321-1366x768-1.jpg" alt="super mario world" /></p>
<div class="custom_caption">
  <p>&gt; A screenshot from super mario word, where several objects such as the enemies and the clouds are drawn several times with the same texture.</p>
</div>

<p>Similarly to the previous part, we can write a C code that performs a drawing through these three different objects.
Starting from our previous C code, we can add the following lines :</p>

<div class="code_frame">C | create_window_c.c </div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="c1">// window creation</span>
<span class="c1">// [...]</span>

<span class="c1">// creating and displaying a drawing</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>
<span class="n">sfImage</span><span class="o">*</span> <span class="n">image</span> <span class="o">=</span> <span class="n">sfImage_create</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span> <span class="c1">// image object</span>

<span class="c1">// coloring a pixel in red at coordinates (42,42)</span>
<span class="n">sfColor</span> <span class="n">color_red</span> <span class="o">=</span> <span class="n">sfColor_fromRGB</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">sfImage_setPixel</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="n">color_red</span><span class="p">);</span>

<span class="n">sfTexture</span><span class="o">*</span> <span class="n">texture</span> <span class="o">=</span> <span class="n">sfTexture_createFromImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// texture object</span>

<span class="n">sfSprite</span><span class="o">*</span> <span class="n">sprite</span> <span class="o">=</span> <span class="n">sfSprite_create</span><span class="p">();</span> <span class="c1">// sprite object</span>
<span class="n">sfSprite_setTexture</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">texture</span><span class="p">,</span> <span class="n">sfTrue</span><span class="p">);</span>

<span class="n">sfRenderWindow_drawSprite</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">sprite</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// display the window</span>
<span class="c1">// [...]</span>

<span class="c1">// dealocate the drawing objects</span>
<span class="c1">// destroy the sprite</span>
<span class="n">sfSprite_destroy</span><span class="p">(</span><span class="n">sprite</span><span class="p">);</span>

<span class="c1">// destroy the texture</span>
<span class="n">sfTexture_destroy</span><span class="p">(</span><span class="n">texture</span><span class="p">);</span>

<span class="c1">// destroy the image</span>
<span class="n">sfImage_destroy</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>

<span class="c1">// [...]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This code can be tested and should add a red pixel üü• in our window, at coordinate (42,42) (the origin being the upper left corner).
We can observe a cascading dependance between each object : the sprite depends on the texture that depends on the image.
At some point, a pointer ‚û°Ô∏è is passed from one object to the next object.</p>

<p>Let‚Äôs generate the result in assembly :</p>

<div class="collapse-panel"><div>
<label for="code_2">Expand</label>
<input type="checkbox" name="" id="code_2" /><span class="collapse-label"></span>
<div class="extensible-content">
<div class="code_frame">Assembly x86-64 | create_window_c.s </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre><span class="c1">; create_window_c.c:22:     sfImage* image = sfImage_create(width, height); // image object</span>
	<span class="nf">mov</span>	<span class="nb">edx</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">56</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; height.0_1, height</span>
	<span class="nf">mov</span>	<span class="nb">eax</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">60</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; width.1_2, width</span>
	<span class="nf">mov</span>	<span class="nb">esi</span><span class="p">,</span> <span class="nb">edx</span>	<span class="c1">;, height.0_1</span>
	<span class="nf">mov</span>	<span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>	<span class="c1">;, width.1_2</span>
	<span class="nf">call</span>	<span class="nv">sfImage_create@PLT</span>	<span class="c1">;</span>
	<span class="nf">mov</span>	<span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">24</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nb">rax</span>	<span class="c1">; image, tmp92</span>


<span class="c1">; create_window_c.c:24:     sfColor color_red = sfColor_fromRGB(255, 0, 0);</span>
	<span class="nf">mov</span>	<span class="nb">edx</span><span class="p">,</span> <span class="mi">0</span>	<span class="c1">;,</span>
	<span class="nf">mov</span>	<span class="nb">esi</span><span class="p">,</span> <span class="mi">0</span>	<span class="c1">;,</span>
	<span class="nf">mov</span>	<span class="nb">edi</span><span class="p">,</span> <span class="mi">255</span>	<span class="c1">;,</span>
	<span class="nf">call</span>	<span class="nv">sfColor_fromRGB@PLT</span>	<span class="c1">;</span>
	<span class="nf">mov</span>	<span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">52</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nb">eax</span>	<span class="c1">; color_red, tmp94</span>

<span class="c1">; create_window_c.c:25:     sfImage_setPixel(image, 42, 42, color_red);</span>
	<span class="nf">mov</span>	<span class="nb">edx</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">52</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp95, color_red</span>
	<span class="nf">mov</span>	<span class="nb">rax</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">24</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp96, image</span>
	<span class="nf">mov</span>	<span class="nb">ecx</span><span class="p">,</span> <span class="nb">edx</span>	<span class="c1">;, tmp95</span>
	<span class="nf">mov</span>	<span class="nb">edx</span><span class="p">,</span> <span class="mi">42</span>	<span class="c1">;,</span>
	<span class="nf">mov</span>	<span class="nb">esi</span><span class="p">,</span> <span class="mi">42</span>	<span class="c1">;,</span>
	<span class="nf">mov</span>	<span class="nb">rdi</span><span class="p">,</span> <span class="nb">rax</span>	<span class="c1">;, tmp96</span>
	<span class="nf">call</span>	<span class="nv">sfImage_setPixel@PLT</span>	<span class="c1">;</span>

<span class="c1">; create_window_c.c:33:     sfTexture* texture = sfTexture_createFromImage(image, NULL); // texture object</span>
	<span class="nf">mov</span>	<span class="nb">rax</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">24</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp97, image</span>
	<span class="nf">mov</span>	<span class="nb">esi</span><span class="p">,</span> <span class="mi">0</span>	<span class="c1">;,</span>
	<span class="nf">mov</span>	<span class="nb">rdi</span><span class="p">,</span> <span class="nb">rax</span>	<span class="c1">;, tmp97</span>
	<span class="nf">call</span>	<span class="nv">sfTexture_createFromImage@PLT</span>	<span class="c1">;</span>
	<span class="nf">mov</span>	<span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">16</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nb">rax</span>	<span class="c1">; texture, tmp98</span>

<span class="c1">; create_window_c.c:35:     sfSprite* sprite = sfSprite_create(); // sprite object</span>
	<span class="nf">call</span>	<span class="nv">sfSprite_create@PLT</span>	<span class="c1">;</span>
	<span class="nf">mov</span>	<span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">8</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nb">rax</span>	<span class="c1">; sprite, tmp99</span>

<span class="c1">; create_window_c.c:36:     sfSprite_setTexture(sprite, texture, sfTrue);</span>
	<span class="nf">mov</span>	<span class="nb">rcx</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">16</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp100, texture</span>
	<span class="nf">mov</span>	<span class="nb">rax</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">8</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp101, sprite</span>
	<span class="nf">mov</span>	<span class="nb">edx</span><span class="p">,</span> <span class="mi">1</span>	<span class="c1">;,</span>
	<span class="nf">mov</span>	<span class="nb">rsi</span><span class="p">,</span> <span class="nb">rcx</span>	<span class="c1">;, tmp100</span>
	<span class="nf">mov</span>	<span class="nb">rdi</span><span class="p">,</span> <span class="nb">rax</span>	<span class="c1">;, tmp101</span>
	<span class="nf">call</span>	<span class="nv">sfSprite_setTexture@PLT</span>	<span class="c1">;</span>

<span class="c1">; create_window_c.c:40:     sfRenderWindow_drawSprite(window, sprite, NULL);</span>
	<span class="nf">mov</span>	<span class="nb">rcx</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">8</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp102, sprite</span>
	<span class="nf">mov</span>	<span class="nb">rax</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">32</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp103, window</span>
	<span class="nf">mov</span>	<span class="nb">edx</span><span class="p">,</span> <span class="mi">0</span>	<span class="c1">;,</span>
	<span class="nf">mov</span>	<span class="nb">rsi</span><span class="p">,</span> <span class="nb">rcx</span>	<span class="c1">;, tmp102</span>
	<span class="nf">mov</span>	<span class="nb">rdi</span><span class="p">,</span> <span class="nb">rax</span>	<span class="c1">;, tmp103</span>
	<span class="nf">call</span>	<span class="nv">sfRenderWindow_drawSprite@PLT</span>	<span class="c1">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

</div></div></div>

<p>We can see that this code is very similar to the previous one : the different objects (image, texture and sprite) are maniuplated through their pointers.
The new type here is <code class="language-plaintext highlighter-rouge">sfColor</code> that stores a color coded on <a href="https://en.wikipedia.org/wiki/RGB_color_model">three components</a> : red üü•, green üü© and blue üü¶ values between <em>0</em> and <em>255</em>.
If we look at the <code class="language-plaintext highlighter-rouge">sfColor</code> definition in the CSFML header, we can see that it is actually composed of 4 8-bits values, one for each color and one for opacity :</p>

<div class="code_frame">C language | Color.h </div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">sfUint8</span> <span class="n">r</span><span class="p">;</span>
    <span class="n">sfUint8</span> <span class="n">g</span><span class="p">;</span>
    <span class="n">sfUint8</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">sfUint8</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span> <span class="n">sfColor</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This implies that we can actually define the color directly with a symbol in our code instead of needing to call the <code class="language-plaintext highlighter-rouge">sfColor_fromRGB</code> function.</p>

<p>Let‚Äôs now add the assembly calls into our program. We first allocate more memory into the stack ü•û in order to store the image, texture and sprite pointers ‚û°Ô∏è :</p>

<div class="code_frame"> create_window_assembly.s | Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="c1">; memory allocation</span>
<span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">40</span>
<span class="c1">; rbp-8 : window pointer, 8 bytes</span>
<span class="c1">; rbp-16 : image pointer, 8 bytes</span>
<span class="c1">; rbp-24 : texture pointer, 8 bytes</span>
<span class="c1">; rbp-32 : sprite pointer, 8 bytes</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We also add the symbol corresponding the red color (red and opacity compenent at 100% üíØ), which is coded on 4 8-bits (1 byte) values :</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nl">color_red:</span>
	<span class="nf">.byte</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>And we can now add the function calls üì£ to create and destroy the objects and to actually draw on the screen :</p>

<div class="collapse-panel"><div>
<label for="code_3">Expand</label>
<input type="checkbox" name="" id="code_3" /><span class="collapse-label"></span>
<div class="extensible-content">

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="c1">; window creation</span>
<span class="c1">; [...]</span>

<span class="c1">; image creation</span>
<span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">window_width</span><span class="p">]</span> <span class="c1">; image width</span>
<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">window_height</span><span class="p">]</span> <span class="c1">; image height</span>
<span class="nf">call</span> <span class="nv">sfImage_create</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="nb">rax</span> <span class="c1">; image ptr</span>

<span class="c1">; draw on the image</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span> <span class="c1">; image ptr</span>
<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="mi">42</span> <span class="c1">; x coordinates</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">42</span> <span class="c1">; y coordinates</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">color_red</span><span class="p">]</span> <span class="c1">; color</span>
<span class="nf">call</span> <span class="nv">sfImage_setPixel</span>

<span class="c1">; texture creation</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span> <span class="c1">; image ptr</span>
<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="mi">0</span>
<span class="nf">call</span> <span class="nv">sfTexture_createFromImage</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">],</span> <span class="nb">rax</span> <span class="c1">; texture ptr</span>

<span class="c1">; sprite creation</span>
<span class="nf">call</span> <span class="nv">sfSprite_create</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">],</span> <span class="nb">rax</span> <span class="c1">; sprite ptr</span>

<span class="c1">; sprite set texture</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span> <span class="c1">; sprite ptr</span>
<span class="nf">mov</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span> <span class="c1">; texture ptr</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">call</span> <span class="nv">sfSprite_setTexture</span>

<span class="c1">; drawing the sprite</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="c1">; window ptr</span>
<span class="nf">mov</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">0</span>
<span class="nf">call</span> <span class="nv">sfRenderWindow_drawSprite</span>

<span class="c1">; window display and sleep</span>
<span class="c1">; [...]</span>

<span class="c1">; sprite destruction</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span>
<span class="nf">call</span> <span class="nv">sfSprite_destroy</span>

<span class="c1">; texure destruction</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
<span class="nf">call</span> <span class="nv">sfTexture_destroy</span>

<span class="c1">; image de destruction</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>
<span class="nf">call</span> <span class="nv">sfImage_destroy</span>

<span class="c1">; window destruction</span>
<span class="c1">; [...]</span>
</pre></td></tr></tbody></table></code></pre></figure>

</div></div></div>

<p>We can see a very typical scheme in the API.
The pointer (memory address) of the object to manipulate is systematically passed to the function.
Additional parameters may also be provided such as a pointer to another object.
In order to choose the right register size for these parameters, it is handy to compile C code into assembly but it is also possible to directly look at the function and type definitions.</p>

<h4 id="drawing-a-rectangle">Drawing a rectangle</h4>

<p>Now that we are able to draw on the screen, we can implement a simple square drawing algorithm.
This is done through two nested ‚Äúfor‚Äù loops.
We first add two local variables in our main function to iterate over the x and y coordinates :</p>

<div class="code_frame"> create_window_assembly.s | Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="c1">; memory allocation</span>
<span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">40</span>
<span class="c1">; rbp-8 : window pointer, 8 bytes</span>
<span class="c1">; rbp-16 : image pointer, 8 bytes</span>
<span class="c1">; rbp-24 : texture pointer, 8 bytes</span>
<span class="c1">; rbp-32 : sprite pointer, 8 bytes</span>
<span class="c1">; rbp-36 : temp x coordinate, 4 bytes</span>
<span class="c1">; rbp-40 : temp y coordinate, 4 bytes</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>By allocating 4 bytes per variable, there is no need to extend the stack ü•û allocation because of the current 16-bytes alignement.
Then, we write our double nested ‚Äúfor‚Äù loop that iterates of the coordinates :</p>

<div class="code_frame"> create_window_assembly.s | Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">36</span><span class="p">],</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="mi">20</span>
<span class="nl">.L_for_temp_x:</span> <span class="c1">; for loop x coordinates</span>

    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">40</span><span class="p">],</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="mi">20</span>
    <span class="nl">.L_for_temp_y:</span> <span class="c1">; for loop y coordinates</span>

        <span class="c1">; draw on the image</span>
        <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span> <span class="c1">; image ptr</span>
        <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">36</span><span class="p">]</span> <span class="c1">; x coordinates</span>
        <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">40</span><span class="p">]</span> <span class="c1">; y coordinates</span>
        <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">color_red</span><span class="p">]</span> <span class="c1">; color</span>
        <span class="nf">call</span> <span class="nv">sfImage_setPixel</span>

        <span class="nf">inc</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">40</span><span class="p">]</span>
        <span class="nf">cmp</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">40</span><span class="p">],</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="mi">50</span>
        <span class="nf">jne</span> <span class="nv">.L_for_temp_y</span>
                
    <span class="nf">inc</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">36</span><span class="p">]</span>
    <span class="nf">cmp</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">36</span><span class="p">],</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="mi">60</span>
    <span class="nf">jne</span> <span class="nv">.L_for_temp_x</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The result should be similar to the following screen capture (upper left part of the screen).</p>

<p><img src="/assets/assembly_series/rectangle_sfml.png" alt="the resulting rectangle" /></p>
<div class="custom_caption">
  <p>&gt; The resulting rectangle (cropped).</p>
</div>

<h4 id="drawing-the-mandelbrot-set">Drawing the Mandelbrot set</h4>

<p>Our last step is now to include our code from the <a href="pt7">previous chapter</a> in order to draw the Mandelbrot set in the window.
This is actually the easy part since all the hard work was done in the last chapter.
We will build from the two functions : <a href="pt7#the-test_convergence-function">test_convergence</a> and <a href="pt7#the-draw_mandelbrot-function-Ô∏è">draw_mandelbrot</a>.</p>

<p>These two functions can be added in a separate file ‚Äúmandelbrot.s‚Äù in order to structure our project as we already did in the previous chapter.
This will require us to add few lines in the Makefile in order to compile ‚öôÔ∏è this new file into an object file and to link üîó it when making the final executable.</p>

<p>The <code class="language-plaintext highlighter-rouge">test_convergence</code> function does not need any modification, it still receives the normalized coordinates as input and decide if the corresponding pixel must be drawn or not.
The <code class="language-plaintext highlighter-rouge">draw_mandelbrot</code> function however needs some adjustments.
First, in order to draw the pixels, it is necessary to pass the image pointer to the function and store it in the stack ü•û :</p>

<div class="code_frame"> mandelbrot.s | Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="c1">; ----------------------------------------------------------</span>
<span class="c1">; draw the ascii mandelbrot set</span>
<span class="c1">; edi: width</span>
<span class="c1">; esi: height</span>
<span class="c1">; rdx: sfImage pointer</span>
<span class="nl">draw_mandelbrot:</span>

    <span class="c1">; stack allocation</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">40</span>
    <span class="c1">; width: rbp-4, 4 bytes</span>
    <span class="c1">; height: rbp-8, 4 bytes</span>
    <span class="c1">; [...]</span>
    <span class="c1">; image pointer: rbp-40, 8 bytes</span>

    <span class="c1">; store the parameters</span>
    <span class="c1">; [...]</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">40</span><span class="p">],</span> <span class="nb">rdx</span>

    <span class="c1">; [...]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Then the printing instructions must be replaced by a call to <code class="language-plaintext highlighter-rouge">sfImage_setPixel</code> function :</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="c1">; .L_if_converge:</span>

    <span class="c1">; draw a pixel</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">40</span><span class="p">]</span> <span class="c1">; image ptr</span>
    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span> <span class="c1">; x coordinates</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span> <span class="c1">; y coordinates</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">color_red</span><span class="p">]</span> <span class="c1">; color</span>
    <span class="nf">call</span> <span class="nv">sfImage_setPixel</span>

    <span class="nf">jmp</span> <span class="nv">.L_end_if_converge</span>

<span class="nl">.L_if_not_converge:</span>

    <span class="c1">; do nothing</span>

<span class="nl">.L_end_if_converge:</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Additionaly, it is necessary to add the <code class="language-plaintext highlighter-rouge">rip</code> register when referencing data at some labels as we saw previously and to remove all the extra printing üñ®Ô∏è instructions.
The last missing piece to our code is the call to <code class="language-plaintext highlighter-rouge">draw_mandelbrot</code> in the <code class="language-plaintext highlighter-rouge">main</code> function that replaces the previous <code class="language-plaintext highlighter-rouge">sfImage_setPixel</code> calls :</p>

<div class="code_frame"> main function | Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="c1">; image creation</span>
<span class="c1">; [...]</span>

<span class="c1">; call the draw_mandelbrot function</span>
<span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">window_width</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">window_height</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span> <span class="c1">; image pointer</span>
<span class="nf">call</span> <span class="nv">draw_mandelbrot</span>

<span class="c1">; texture creation</span>
<span class="c1">; [...]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Everything should now be in place to compile and test our program :</p>

<p><img src="/assets/assembly_series/sfml_mandelbrot.png" alt="the resulting mandelbrot set" /></p>
<div class="custom_caption">
  <p>&gt; Our Mandelbrot set in an SFML window!</p>
</div>

<p>Perfect! ü•≥ Feel free to improve the figure by adding colors depending on the number of iterations when testing the convergence for instance üòÉ.</p>

<h2 id="bonus--coding-the-window-loop">Bonus : coding the window loop</h2>

<p>Our goal is already achieved in this chapter but we did not exploit the full potential of window ü™ü application as the user cannot interact with the window yet.
For instance, it would be great if we could close the application through the dedicated window button ‚ùå.</p>

<p>Instead of digging in the documentation we can already observe how the main window loop is coded in C and use automatic assembly code generation to take some inspiration üò§.
Here is the basic code scheme :</p>

<div class="code_frame">C language | main_window_loop </div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="c1">// create the main window</span>
<span class="c1">// [...]</span>

<span class="c1">//-------------------------------------------------</span>
<span class="c1">// Start the application loop</span>
<span class="n">sfEvent</span> <span class="n">event</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">sfRenderWindow_isOpen</span><span class="p">(</span><span class="n">window</span><span class="p">))</span> <span class="p">{</span>

    <span class="c1">// Process events</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">sfRenderWindow_pollEvent</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// Close window : exit</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">sfEvtClosed</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sfRenderWindow_close</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// draw in the window</span>
    <span class="c1">// [...]</span>

    <span class="c1">// Update the window</span>
    <span class="n">sfRenderWindow_display</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// destroy the window</span>
<span class="c1">// [...]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This loop, when inserted in between the window object allocation and its deallocation, should allow the user to contemplate the window ü™ü until they closes it with the cross.
All the drawing code must go just before the display function call.</p>

<p>In order to allow the user to interact with the window, the program must check the ‚Äúevents‚Äù.
Events are of different type : mouse button pressed üñ±Ô∏è, key pressed ‚å®Ô∏è, window button triggered ‚ùå, etc..
Since multiple events may be present at each iteration, a while loop üîÅ helps processing them all at once.</p>

<p>In our assembly code, this means that we need to call 3 new functions : <code class="language-plaintext highlighter-rouge">sfRenderWindow_isOpen</code>, <code class="language-plaintext highlighter-rouge">sfRenderWindow_pollEvent</code> and <code class="language-plaintext highlighter-rouge">sfRenderWindow_close</code>.
The most difficult part will be to understand how the event type is coded.
To do so, we can write a small C program that creates and processes an event :</p>

<div class="code_frame">C language </div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="c1">// window creation</span>
<span class="c1">// [...]</span>

<span class="c1">// test with the event type</span>
<span class="n">sfEvent</span> <span class="n">event</span><span class="p">;</span>

<span class="c1">// output the size of sfEvent struct, in bytes</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"event size: %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sfEvent</span><span class="p">));</span>

<span class="c1">// function call needing an sfEvent pointer</span>
<span class="n">sfRenderWindow_pollEvent</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>

<span class="n">event</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">sfEvtClosed</span><span class="p">;</span>

<span class="c1">// window destruction</span>
<span class="c1">// [...]</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>When compiled into an executable, this program indicates that the size (in bytes) of the <code class="language-plaintext highlighter-rouge">sfEvent</code> type is <strong>28</strong> thanks to the <code class="language-plaintext highlighter-rouge">sizeof</code> operator.
This information will be useful when allocating space in the stack ü•û to store the event variable.</p>

<p>We can now automatically generate the corresponding assembly code for the lines of interest :</p>

<div class="code_frame">Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="c1">; test_event.c:21:     printf("event size: %ld\n", sizeof(sfEvent));</span>
	<span class="nf">mov</span>	<span class="nb">esi</span><span class="p">,</span> <span class="mi">28</span>	<span class="c1">;,</span>
	<span class="nf">lea</span>	<span class="nb">rax</span><span class="p">,</span> <span class="nv">.LC1</span><span class="p">[</span><span class="nv">rip</span><span class="p">]</span>	<span class="c1">; tmp90,</span>
	<span class="nf">mov</span>	<span class="nb">rdi</span><span class="p">,</span> <span class="nb">rax</span>	<span class="c1">;, tmp90</span>
	<span class="nf">mov</span>	<span class="nb">eax</span><span class="p">,</span> <span class="mi">0</span>	<span class="c1">;,</span>
	<span class="nf">call</span>	<span class="nv">printf@PLT</span>	<span class="c1">;</span>

<span class="c1">; test_event.c:23:     sfRenderWindow_pollEvent(window, &amp;event);</span>
	<span class="nf">lea</span>	<span class="nb">rdx</span><span class="p">,</span> <span class="o">-</span><span class="mi">48</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp91,</span>
	<span class="nf">mov</span>	<span class="nb">rax</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">56</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp92, window</span>
	<span class="nf">mov</span>	<span class="nb">rsi</span><span class="p">,</span> <span class="nb">rdx</span>	<span class="c1">;, tmp91</span>
	<span class="nf">mov</span>	<span class="nb">rdi</span><span class="p">,</span> <span class="nb">rax</span>	<span class="c1">;, tmp92</span>
	<span class="nf">call</span>	<span class="nv">sfRenderWindow_pollEvent@PLT</span>	<span class="c1">;</span>

<span class="c1">; test_event.c:25:     event.type = sfEvtClosed;</span>
	<span class="nf">mov</span>	<span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">48</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="mi">0</span>	<span class="c1">; event.type,</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can see at line 2 that the size of <code class="language-plaintext highlighter-rouge">sfEvent</code>,  <em>28</em>, is directly hard-coded into the assembly code.
That is beacause the <code class="language-plaintext highlighter-rouge">sizeof</code> operator in C is processed at <a href="https://www.geeksforgeeks.org/sizeof-operator-c/">compile time</a>.</p>

<p>Line <em>9</em> indicates that the event is located at address <code class="language-plaintext highlighter-rouge">rbp-48</code> in the stack ü•û.
Since its size is <code class="language-plaintext highlighter-rouge">28</code>, this means that the event is contained in the stack from address <code class="language-plaintext highlighter-rouge">rbp-48</code> to address <code class="language-plaintext highlighter-rouge">rpb-20</code>.
Then, we can see at line <em>16</em> that the field <code class="language-plaintext highlighter-rouge">type</code> in the event is actually the first field of the structure, since its address is also the base address of the event (<code class="language-plaintext highlighter-rouge">rbp-48</code>) in the stack.
We also learn that the 4 bytes value <em>0</em> code for the event value <code class="language-plaintext highlighter-rouge">sfEvtClosed</code>.</p>

<p>We can use these information to create a new program in assembly that performs the classical main loop :</p>

<div class="collapse-panel"><div>
<label for="code_4">Expand</label>
<input type="checkbox" name="" id="code_4" /><span class="collapse-label"></span>
<div class="extensible-content">
<div class="code_frame">Assembly x86-64 | main_window_loop_assembly.s </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="code"><pre><span class="nl">main:</span>
    
    <span class="c1">; [...]</span>

    <span class="c1">; stack allocation</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">72</span>
    <span class="c1">; rbp-8 : window pointer, 8 bytes</span>
    <span class="c1">; rbp-16 : image pointer, 8 bytes</span>
    <span class="c1">; rbp-24 : texture pointer, 8 bytes</span>
    <span class="c1">; rbp-32 : sprite pointer, 8 bytes</span>
    <span class="c1">; rbp-36 ; temp x coordinate, 4 bytes</span>
    <span class="c1">; rbp-40 ; temp y coordinate, 4 bytes</span>
    <span class="c1">; rbp-68 ; event, 28 bytes</span>

    <span class="c1">; storing the preserved registers</span>
    <span class="c1">; [...]</span>

    <span class="c1">; window creation</span>
    <span class="c1">; [...]</span>

    <span class="c1">; main window loop</span>
    <span class="nl">.L_while_window_open:</span>

        <span class="c1">; test if window is open </span>
        <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="c1">; window pointer</span>
        <span class="nf">call</span> <span class="nv">sfRenderWindow_isOpen</span>
        <span class="nf">test</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
        <span class="nf">jz</span> <span class="nv">.L_end_while_window_open</span>

        <span class="c1">; poll event loop</span>
        <span class="nl">.L_while_poll_event:</span>

            <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="c1">; window ptr</span>
            <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">68</span><span class="p">]</span> <span class="c1">; event ptr</span>
            <span class="nf">call</span> <span class="nv">sfRenderWindow_pollEvent</span>

            <span class="c1">; leave poll event loop if no eventw</span>
            <span class="nf">test</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
            <span class="nf">jz</span> <span class="nv">.L_end_while_pool_event</span>

            <span class="c1">; test event type and close the window if required</span>
            <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">68</span><span class="p">]</span>
            <span class="nf">test</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
            <span class="nf">jnz</span> <span class="nv">.L_end_if_event_equal_close</span> 

            <span class="nl">.L_if_event_equal_close:</span>
                <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="c1">; window ptr</span>
                <span class="nf">call</span> <span class="nv">sfRenderWindow_close</span>
            <span class="nl">.L_end_if_event_equal_close:</span>

            <span class="nf">jmp</span> <span class="nv">.L_while_poll_event</span>
        <span class="nl">.L_end_while_pool_event:</span>

        <span class="c1">; window draw instruction</span>

        <span class="c1">; calling "display"</span>
        <span class="nf">mov</span>	<span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
        <span class="nf">call</span> <span class="nv">sfRenderWindow_display</span>

        <span class="nf">jmp</span> <span class="nv">.L_while_window_open</span>
    <span class="nl">.L_end_while_window_open:</span>

    <span class="c1">; window destruction</span>
    <span class="c1">; [...]</span>

    <span class="c1">; restoring registers</span>
    <span class="c1">; [...]</span>

    <span class="c1">; return</span>
    <span class="c1">; [...]</span>
</pre></td></tr></tbody></table></code></pre></figure>

</div></div></div>

<p>Once again, I ommitted in this code instructions that are not related to the main loop itself.
We can see the two nested while loops üîÅ, one for keeping the window ü™ü open and another one for polling the events.
These loops are implemented slightly differently to what we saw previously : a systematic jump ü¶ò is present at the end of each loop iteration.
The termination test is the performed at the beginning of the loop, before executing its instructions.
This is actually necessary in order to perform a proper <code class="language-plaintext highlighter-rouge">while</code> loop, where the termination test is done at the beginning.</p>

<p>Other than that, the different function calls üì£ are performed in order to gather the events, test if the window is open and close it when necessary.
We can see that the <code class="language-plaintext highlighter-rouge">lea</code> instruction is necessary to pass the event to the function as it is given as a pointer ‚û°Ô∏è (hence its memory address in the stack ü•û).
Moreover, the return value is coded on 4 bytes, as we could guess on the assembly code, and the <code class="language-plaintext highlighter-rouge">test</code> instruction is used to perform the tests.</p>

<p>What remains is adding our Mandelbrot code to draw the Mandelbrot set inside the main loop.
The sprite should be displayed just before calling the window display function.
However, the function that draws on the image can be called only once at the beginning of the program (outside the main loop).</p>

<h2 id="whats-next-">What‚Äôs next ?</h2>

<p>This chapter should already give a taste of what‚Äôs possible when developing in assembly.
This is going to be the last chapter in this series as my primary goal was simply to show that assembly is just a language like another.
I really hope the this series helps to narrow the gap between highy level programming and low level program execution.</p>

<p>The codes from this chapter are available at <a href="https://github.com/smbct/x86-64_101_linux/tree/main/pt8_graphical_mandelbrot">this link</a>.
Feel free to improve this code by, for instance, adding colors, zoom, mouse input, etc‚Ä¶
At some point, developing in assembly should feel just a little less comfortable that using higher level languages üòá.</p>

<p>I will probably not be done with assembly yet as I still have some project ideas at the lower level of coding!
Stay tuned! ü•≥</p>

    



<div class="post-tags">
  
</div>
  </div>

  

  
  <section class="comments">
    <!-- <h2>Comments</h2> -->
    <script src="https://giscus.app/client.js"
        data-repo="smbct/smbct.github.io"
        data-repo-id="R_kgDOL0ffhg"
        data-category="Announcements"
        data-category-id="DIC_kwDOL0ffhs4CfYJ5"
        data-mapping="title"
        data-strict="1"
        data-reactions-enabled="0"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
  </script>

  </section>


</div>




<p class="back-link">
    <a href="/series/x86_64_assembly/headline.html"><span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>Assembly x86-64 programming 101</a>
</p>


    </main>

    <!-- Optional footer content -->

  </body>
</html>
