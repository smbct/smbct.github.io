<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Assembly x86 programming 101 &#58 part 4, recursive fibonacci &middot; smbct's blog
    
  </title>

  <!-- 
 -->

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="post">

    <div id="sidebar">
  <header>
    <div class="site-title">
      <a href="/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        smbct's blog
      </a>
    </div>
    <p class="lead">Notes on computer science, programming, society and more.</p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link "
        href="/">Home</a>
  
  

  

  


  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  



  <a class="category-link "
          href="/pages/series.html">Series </a>

  


  
    
  

  
    
      <a class="category-link "
          href="/pages/about.html">About</a>
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">

  
    <a id="github-link"
       class="icon" title="Github Profile" aria-label="Github Profile"
       href="https://github.com/smbct">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 28" height="24" width="28"><path d="M12 2c6.625 0 12 5.375 12 12 0 5.297-3.437 9.797-8.203 11.391-0.609 0.109-0.828-0.266-0.828-0.578 0-0.391 0.016-1.687 0.016-3.297 0-1.125-0.375-1.844-0.812-2.219 2.672-0.297 5.484-1.313 5.484-5.922 0-1.313-0.469-2.375-1.234-3.219 0.125-0.313 0.531-1.531-0.125-3.187-1-0.313-3.297 1.234-3.297 1.234-0.953-0.266-1.984-0.406-3-0.406s-2.047 0.141-3 0.406c0 0-2.297-1.547-3.297-1.234-0.656 1.656-0.25 2.875-0.125 3.187-0.766 0.844-1.234 1.906-1.234 3.219 0 4.594 2.797 5.625 5.469 5.922-0.344 0.313-0.656 0.844-0.766 1.609-0.688 0.313-2.438 0.844-3.484-1-0.656-1.141-1.844-1.234-1.844-1.234-1.172-0.016-0.078 0.734-0.078 0.734 0.781 0.359 1.328 1.75 1.328 1.75 0.703 2.141 4.047 1.422 4.047 1.422 0 1 0.016 1.937 0.016 2.234 0 0.313-0.219 0.688-0.828 0.578-4.766-1.594-8.203-6.094-8.203-11.391 0-6.625 5.375-12 12-12zM4.547 19.234c0.031-0.063-0.016-0.141-0.109-0.187-0.094-0.031-0.172-0.016-0.203 0.031-0.031 0.063 0.016 0.141 0.109 0.187 0.078 0.047 0.172 0.031 0.203-0.031zM5.031 19.766c0.063-0.047 0.047-0.156-0.031-0.25-0.078-0.078-0.187-0.109-0.25-0.047-0.063 0.047-0.047 0.156 0.031 0.25 0.078 0.078 0.187 0.109 0.25 0.047zM5.5 20.469c0.078-0.063 0.078-0.187 0-0.297-0.063-0.109-0.187-0.156-0.266-0.094-0.078 0.047-0.078 0.172 0 0.281s0.203 0.156 0.266 0.109zM6.156 21.125c0.063-0.063 0.031-0.203-0.063-0.297-0.109-0.109-0.25-0.125-0.313-0.047-0.078 0.063-0.047 0.203 0.063 0.297 0.109 0.109 0.25 0.125 0.313 0.047zM7.047 21.516c0.031-0.094-0.063-0.203-0.203-0.25-0.125-0.031-0.266 0.016-0.297 0.109s0.063 0.203 0.203 0.234c0.125 0.047 0.266 0 0.297-0.094zM8.031 21.594c0-0.109-0.125-0.187-0.266-0.172-0.141 0-0.25 0.078-0.25 0.172 0 0.109 0.109 0.187 0.266 0.172 0.141 0 0.25-0.078 0.25-0.172zM8.937 21.438c-0.016-0.094-0.141-0.156-0.281-0.141-0.141 0.031-0.234 0.125-0.219 0.234 0.016 0.094 0.141 0.156 0.281 0.125s0.234-0.125 0.219-0.219z"></path>
</svg>

    </a>
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  

  <!-- Optional additional links to insert for icons links -->
</nav>

  <p>
  &copy; 2024.
  <a href="/LICENSE.md">MIT License.</a>
</p>

</div>

    <main class="container">
      <header>
  <h1 class="post-title">Assembly x86 programming 101 &#58 part 4, recursive fibonacci</h1>
</header>
<div class="content">
  <div class="post-meta">
  <span class="post-date">14 May 2024</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        low-level programming assembly
      
    
  </span>
</div>


  <div class="post-body">
    <p>In the last post of the assembly x86 series, we have seen how to manipulate the stack in order to store local variables.
The stack is also essential for <strong>calling functions</strong> : it is used to store information such as the return instruction address.
In this post, we will see how to write and call functions, and also how to interact with C functions in our program!
We will use these new notions to print the content of an integer array in assembly.</p>

<h2 id="more-about-the-stack--pushing-and-popping-values">More about the stack : pushing and popping values</h2>

<p>Before diving into the mechanism of function calls, we should see two important instructions related to the stack that were bot mentioned in the previous post : <code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">pop</code>.
The <code class="language-plaintext highlighter-rouge">push</code> instruction allows to move a value to the stack in an automated way.
This instruction will concretely perform two operations :</p>

<ul>
  <li>subtracting the stack address to allocate some bytes in the stack</li>
  <li>moving the value at the resulting address in the stack</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">pop</code> is the reversed instruction : it moves the value from the stack to a register and increases the stack pointer accordingly.
Let’s create a simple example :</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">_start</span><span class="p">,</span> <span class="nv">debug</span><span class="p">,</span> <span class="nv">debug2</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="nl">_start:</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="c1">; moving the value 42 into 8 bytes in the stack</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">8</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rsp</span><span class="p">],</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="mi">42</span>

    <span class="nl">debug:</span>

    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>

    <span class="c1">; exit</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">60</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">syscall</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Nothing new here, we allocate 8 bytes on the stack and we store the value 42.
We will check that the value is properly stored : run GDB on the program, type <code class="language-plaintext highlighter-rouge">b debug</code> and <code class="language-plaintext highlighter-rouge">run</code> to stop just after the move.
After that, execute the commands <code class="language-plaintext highlighter-rouge">print $rbp</code> and <code class="language-plaintext highlighter-rouge">print $rsp</code>.
This gives me <em>0x7fffffffdda0</em> and <em>0x7fffffffdd98</em>.
<em>98-a0=-8</em> in hexadecimal, the 8 bits have been allocated (<em>0x</em> here simply means hexadecimal).</p>

<p>Now we would check the value, directly from the stack this time : <code class="language-plaintext highlighter-rouge">print *0x7fffffffdd98</code> (in this step, you should replace the specified address by the output you obtained with the <code class="language-plaintext highlighter-rouge">print $rsp</code> command).
The star character (*) here is used to specify an address. 
We end up with the value <em>42</em>, perfect!
Note that alternative command <code class="language-plaintext highlighter-rouge">x/dg 0x7fffffffdd98</code> could also be used to print the value, where <em>x</em> stands for “examining” memory.
<a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Memory.html#Memory">This page</a> shows the different options such as the output format and the number of bytes to read.</p>

<p>Now let’s modify this code with the push instruction and let’s add a pop instruction afterward :</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="nl">_start:</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="c1">; moving the value 42 into 8 bytes in the stack</span>
    <span class="nf">push</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="mi">42</span>

    <span class="nl">debug:</span>

    <span class="nf">pop</span> <span class="nb">rax</span>

    <span class="nl">debug2:</span>

    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>

    <span class="c1">; exit</span>
    <span class="c1">; ...</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can use GDB with the previous commands to check that the <code class="language-plaintext highlighter-rouge">push</code> instruction did exactly the same as a <code class="language-plaintext highlighter-rouge">sub</code> followed by a <code class="language-plaintext highlighter-rouge">mov</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) break debug
(gdb) break debug2
(gdb) print $rbp
$1 = (void *) 0x7fffffffdda0
(gdb) print $rsp
$2 = (void *) 0x7fffffffdd98
(gdb) print *0x7fffffffdd98
$3 = 42
(gdb) print 0x7fffffffdda0-0x7fffffffdd98
$4 = 8
</code></pre></div></div>

<p>Alright, that is indeed an 8 bytes allocation followed by the value 42 being stored in the stack.
Now let’s inspect the action of <code class="language-plaintext highlighter-rouge">pop</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) continue
(gdb) print $rsp
$5 = (void *) 0x7fffffffdda0
(gdb) print $rbp
$6 = (void *) 0x7fffffffdda0
(gdb) print $rax
$7 = 42
</code></pre></div></div>

<p>This is it.
After the <code class="language-plaintext highlighter-rouge">pop</code> instruction, the <code class="language-plaintext highlighter-rouge">rsp</code> register is now equal to the <code class="language-plaintext highlighter-rouge">rbp</code> register, which means the stack pointer took back its value before our allocation.
We can see the second effect of the <code class="language-plaintext highlighter-rouge">pop</code> instruction : the popped value is now stored in the <code class="language-plaintext highlighter-rouge">rax</code> register.</p>

<h2 id="writing-basic-functions">Writing basic functions</h2>

<p>We have discovered in a previous post of the series the <code class="language-plaintext highlighter-rouge">jmp</code> instruction which allows to go to a certain location in the program’s code.
You may guess that this is the same mechanism at the base of function call : a jump is performed to the first instruction of the called function.
However, when the execution of the function is terminated, the program must go back to the instruction that follows this <code class="language-plaintext highlighter-rouge">jmp</code>.
To do so, we will see the <code class="language-plaintext highlighter-rouge">call</code> and <code class="language-plaintext highlighter-rouge">ret</code> instructions that take care of this.</p>

<h4 id="writing-and-calling-our-first-function">Writing and calling our first function</h4>

<p>Let’s start with a simple function that prints “hello world” :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">.global</span> <span class="nv">_start</span><span class="p">,</span> <span class="nv">_before_call</span><span class="p">,</span> <span class="nv">_after_call</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="nl">_print_hello_world:</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">hello_world</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">14</span>
    <span class="nf">syscall</span>
    <span class="nf">ret</span>

<span class="nl">_start:</span>

    <span class="nl">_before_call:</span>
    <span class="nf">call</span> <span class="nv">_print_hello_world</span>
    <span class="nl">_after_call:</span>

    <span class="c1">; exit</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">60</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">69</span>
    <span class="nf">syscall</span>

<span class="nl">hello_world:</span>
    <span class="nf">.asciz</span> <span class="err">"</span><span class="nv">Hello</span><span class="p">,</span> <span class="nv">World</span><span class="err">!\</span><span class="nv">n</span><span class="err">"</span>

</code></pre></div></div>

<p>Compared to our hello_world example, this code simply encapsulates the printing instructions within a function by the use of a new symbol (“_print_hello_world”).
The function is executed with the <code class="language-plaintext highlighter-rouge">call</code> instruction and the program returns the the <code class="language-plaintext highlighter-rouge">_start</code> function execution thanks to the <code class="language-plaintext highlighter-rouge">ret</code> instruction.
We will use the two additional symbols “_before_call” and “_after_call” as debugging labels with gdb to see how it works.</p>

<p>Calling functions brings a new dimension in our code : we are now manipulating the program’s instructions addresses at runtime.
Indeed, when a function is being executed, the program must remember the address of the instruction that calls the function (in the program’s memory, where all instructions are loaded).
By doing so, at the return instruction the programs knows where to “return” in the program’s memory.
There exists a register that is dedicated to store the address of the next instruction to be executed : the <code class="language-plaintext highlighter-rouge">rip</code> register (Relative Instruction Pointer).
We will use look at this register to understand our program.</p>

<h4 id="how-function-calls-work">How function calls work</h4>

<p>Let’s use gdb on the previous code to see what is happening.
We add breakpoints at <code class="language-plaintext highlighter-rouge">_before_call</code>, <code class="language-plaintext highlighter-rouge">_print_hello_world</code> (just after the <code class="language-plaintext highlighter-rouge">call</code> instruction) and at <code class="language-plaintext highlighter-rouge">_after_call</code> to see how the stack is manipulated.
After executing the <code class="language-plaintext highlighter-rouge">run</code> command in gdb, the program will start and pause at <code class="language-plaintext highlighter-rouge">_before_call</code>, just before the function call.
To illustrate the <code class="language-plaintext highlighter-rouge">rip</code> register mentioned before, we can already print the pointed instruction with :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/i $rip
=&gt; 0x401020 &lt;_start&gt;:	call   0x401000 &lt;_print_hello_world&gt;
</code></pre></div></div>

<p>We can see the address, <em>0x401020</em> and the encoded instruction which is our <code class="language-plaintext highlighter-rouge">call</code>.
Let’s also print our stack pointer address : <code class="language-plaintext highlighter-rouge">print $rsp</code>, which gives <em>0x7fffffffdda0</em> in my case.
Then, the <code class="language-plaintext highlighter-rouge">continue</code> command makes the program stops at <code class="language-plaintext highlighter-rouge">_print_hello_world</code>.
We will see what changed on the stack :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Breakpoint 3, 0x0000000000401000 in _print_hello_world ()
(gdb) print $rsp
$3 = (void *) 0x7fffffffdd98
(gdb) x *0x7fffffffdd98
   0x401025 &lt;_after_call&gt;:	mov    $0x3c,%rax
(gdb) print 0x7fffffffdd98-0x7fffffffdda0
$4 = -8
</code></pre></div></div>

<p>We can see that the <code class="language-plaintext highlighter-rouge">rsp</code> register has changed from <em>0x7fffffffdda0</em> to <em>0x7fffffffdd98</em>.
8 Bytes have been allocated : the program has stored the return address of the function call.
Indeed, by printing the instruction at the corresponding location, we see that it corresponds to the instruction that follows the <code class="language-plaintext highlighter-rouge">call</code> one in the <code class="language-plaintext highlighter-rouge">_start</code> function : <code class="language-plaintext highlighter-rouge">mov $0x3c,%rax</code> (<em>0x3c</em> corresponds to the value 60 in decimal).</p>

<p>We continue the execution to see what happens when returning from the function :</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Continuing.
Hello, World!

Breakpoint 2, 0x0000000000401025 in _after_call ()
(gdb) print $rsp
$5 = (void *) 0x7fffffffdda0
(gdb) x/i $rip
=&gt; 0x401025 &lt;_after_call&gt;:	mov    $0x3c,%rax
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">continue</code> command in gdb now brings us at the <code class="language-plaintext highlighter-rouge">_after_call</code> label.
We can see that the <code class="language-plaintext highlighter-rouge">rsp</code> register took back its value from before the call, the return address was is no longer necessary and is popped out with the <code class="language-plaintext highlighter-rouge">ret</code> instruction.
We additionally print the value of the <code class="language-plaintext highlighter-rouge">rip</code> register : the value is the same as the one previously stored on the stack.</p>

<h2 id="writing-a-recursive-pow-function">Writing a recursive pow function</h2>

<p>We will now study more complex functions to gain a deeper understanding of how the stack is manipulated when functions are called.
A good exercise for this is recursion : a recursive function (a function that calls itself) must pay attention to preserve the stack in coherent state, in order to avoid unpredicted behaviors.</p>

<p>In this part, we will write a function that wil compute the exponentiation of a number recursively, by performing successive multiplications.
Such operation would easily be done with a simple loop but the recursive way is going to be more instructive.</p>

<h4 id="passing-parameters-through-the-stack">Passing parameters through the stack</h4>

<p>We have previously seen how to write a simple function that takes no parameters and that returns nothing.
In practice, parameters and return values are essential to our programs.
There are actually different ways to pass information between the functions : you may pass parameters into registers for instance or store them into the stack, it depends on the <strong>convention</strong> that is adopted.</p>

<p>We will start or pow function by passing the two parameters (the base and the exponent) to our function.
In this example, we pass the values by using the stack :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">_pow_rec:</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>
    <span class="nf">mov</span> <span class="nb">rbx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>
    <span class="nl">debug:</span>
    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">ret</span>

<span class="nl">_start:</span>
    <span class="c1">; pushing the two parameters to the stack</span>
    <span class="nf">push</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="mi">5</span> <span class="c1">; base</span>
    <span class="nf">push</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="mi">4</span> <span class="c1">; exponent</span>

    <span class="nf">call</span> <span class="nv">_pow_rec</span>

    <span class="c1">; popping the parameters stored on the stack</span>
    <span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">16</span>

    <span class="c1">; exit</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">60</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">syscall</span>
</code></pre></div></div>

<p>In this code, the <code class="language-plaintext highlighter-rouge">_start</code> function starts by placing the two parameters of our pow function on the stack.
The first parameter to be push is the base and the second one is the exponent, hence we expect to compute <em>5^4</em> here.
The <code class="language-plaintext highlighter-rouge">_start</code> then calls the <code class="language-plaintext highlighter-rouge">_pow_rec</code> function and after that it removes the values from the stack with the <code class="language-plaintext highlighter-rouge">add</code> instructions (2* (8 bytes)).</p>

<p>For now, our <code class="language-plaintext highlighter-rouge">_pow_rec</code> function only extracts one of the parameter from the stack.
Since this function will use the stack, we added the rwo <code class="language-plaintext highlighter-rouge">mov</code> instructions to save and restore the stack pointer, as we saw in the previous post of the series on the local variables allocation.
However at this point, since no additional data is stored in stack, the <code class="language-plaintext highlighter-rouge">rbp</code> and <code class="language-plaintext highlighter-rouge">rsp</code> registers would be equal during the function’s execution.</p>

<p>You can test run the program in gdb and add a breakpoint at <code class="language-plaintext highlighter-rouge">debug</code> to test the <code class="language-plaintext highlighter-rouge">rbx</code> register.
The resulting value is <em>4</em>, which corresponds to the exponent parameter.
The value is accessed by adding <em>8</em> to the <code class="language-plaintext highlighter-rouge">rbp</code> register.
This can be understand from the fact that the stack pointer points toward the return address of the function call (8 bytes) as we saw previously.
This means that <code class="language-plaintext highlighter-rouge">rsp+8</code> points to the last value added to the stack before the call (as the stack grows toward lower addresses), which corresponds to the exponent parameter in our case.
By going further in the stack we end up finding the base parameter, 16 bytes above the current stack address.</p>

<p>Let’s now store the two parameters on the stack by allocating two 8 bytes local variables :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">_pow_rec:</span>
    
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="c1">; base : offset=rbp-8, size=8</span>
    <span class="c1">; exponent : offset=rbp-16, size=8</span>

    <span class="c1">; storing the base parameter</span>
    <span class="nf">mov</span> <span class="nb">rbx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">rbx</span>

    <span class="c1">; storing the exponent parameter</span>
    <span class="nf">mov</span> <span class="nb">rbx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">+</span><span class="mi">16</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="nb">rbx</span>

    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">ret</span>
</code></pre></div></div>

<h4 id="our-first-recursive-function">Our first recursive function</h4>

<p>Now we can now write the recursion, the central part of our algorithm.
Our program will first accumulate the function calls on the stack until the exponent <em>0</em> is reached.
Once it is done, the function can return 1 (x^0 = 1 for all x) without any additional recursive call.
After that, the function calls would be unstacked and each time, as the results of the previous call would be multiplied by the base.</p>

<p>To implement this, we separate the base case, when the exponent is 0, from the general case :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">_pow_rec:</span>
    
    <span class="c1">; saving the stack register and allocating memory</span>
    <span class="c1">; ...</span>

    <span class="c1">; storing the parameters on the stack</span>
    <span class="c1">; ...</span>

    <span class="c1">; compare the exponent to 0</span>
    <span class="nf">mov</span> <span class="nb">rbx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>
    <span class="nf">test</span> <span class="nb">rbx</span><span class="p">,</span> <span class="nb">rbx</span>
    <span class="nf">jnz</span> <span class="nv">else_exponent_not_0</span>

    <span class="nl">.L_if_exponent_0:</span>

        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">jmp</span> <span class="nv">endif</span>

    <span class="nl">.L_else_exponent_not_0:</span>

        <span class="nf">dec</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>

        <span class="c1">; store the left and right parameters for the next recursive call</span>
        <span class="nf">push</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
        <span class="nf">push</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>

        <span class="nf">call</span> <span class="nv">_pow_rec</span> <span class="c1">; the recursive call</span>
        <span class="nf">imul</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="c1">; compute the result</span>

        <span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">16</span>

    <span class="nl">.L_endif:</span>

    <span class="c1">; restoring the stack pointer and returning</span>
    <span class="c1">; ...</span>

</code></pre></div></div>

<p>The first part of the algorithm is the comparison of the exponent value with 0, indirectly done through the <code class="language-plaintext highlighter-rouge">rbx</code> register.
Here this comparison is performed with the <code class="language-plaintext highlighter-rouge">test</code> <a href="https://en.wikipedia.org/wiki/TEST_(x86_instruction)">instruction</a> that performs a logical and operation and sets an internal flag depending on the result.
The <code class="language-plaintext highlighter-rouge">jnz</code> instruction (jump if not zero) will be triggered if the tested value (<code class="language-plaintext highlighter-rouge">rbx</code> here) is not equal to zero, as the instruction says.</p>

<p>The following instructions emulate an if..else.. statement, where the first condition corresponds to the base equal to 0.
In this example, we choose to put the return value of the function in the <code class="language-plaintext highlighter-rouge">rax</code> register, which is handled in these two different conditions without using additional memory.
In the first case, the value 1 is simply moved to the register and the program jumps to the end of the function, to skip the second case’s instructions.
In the second case, the base variable is first decremented and the recursive call is performed after pushing the parameters to the stack.</p>

<h4 id="preserving-the-stack-pointers-across-function-calls">Preserving the stack pointers across function calls</h4>

<p>If you test the complete function by adding the remaining instructions from the previous code snippet, you would observe an infinite loop!
There is one crucial missing step in our code that handles the stack pointers.
For now we had only performed function calls from the main function.</p>

<p>We have seen how to save the stack pointer and restore it at the end of the function but we did not do anything for the base pointer.
That is the issue here : the base pointer is modified in each sub call.
Hence, when returning in the function, the base pointer which is then written in <code class="language-plaintext highlighter-rouge">rsp</code> is no longer valid, causing the function to return in the wrong place.
In this situation, since the sub-calls are recursive calls, the function actually returns inside itself, just after the recursive call.</p>

<p>We will now change the function’s base code to :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">_my_function_base:</span>
    
    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="c1">; allocate memory</span>
    <span class="c1">; ...</span>
    <span class="c1">; compute stuff</span>
    <span class="c1">; ...</span>

    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>
    <span class="nf">ret</span>
</code></pre></div></div>

<p>The two additional <code class="language-plaintext highlighter-rouge">push</code> instructions here make sure that the <code class="language-plaintext highlighter-rouge">rbp</code> register is saved and restore at each function call.
This is handled in the called function directly, which is convenient for readability as these instructions would always be the at the beginning and at the end the our functions.</p>

<p>We can now add the first instructions of the functions (indicated by comments in the previous snippet) :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">16</span>
    <span class="c1">; rbp-8 : base (8 bytes)</span>
    <span class="c1">; rbp-16 : exponent (8 bytes)</span>

    <span class="c1">; store the local variables</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">+</span><span class="mi">24</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">rax</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">+</span><span class="mi">16</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="nb">rax</span>
</code></pre></div></div>

<p>Note that since the stack now contains one more 8-byte value, the addresses of the parameters, relative to <code class="language-plaintext highlighter-rouge">rbp</code>, should be changed by subtracting 8 additional bytes hence the modification.</p>

<p>And here is how the function is exited :</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>
    <span class="nf">ret</span>
</code></pre></div></div>

<h4 id="memory-usage-with-recursion">Memory usage with recursion</h4>

<h2 id="writing-a-recursive-fibonacci-function">Writing a recursive Fibonacci function</h2>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; compute a fibonacci number recursively</span>
<span class="nl">_compute_fibonacci_rec:</span>
    
    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">18</span>
    <span class="c1">; local variables:</span>
    <span class="c1">; rbp-18 : sequence index, 2 bytes</span>
    <span class="c1">; rbp-16 : f_(n-2), 8 bytes</span>
    <span class="c1">; rbp-8 : f_(n-1), 8 bytes</span>

    <span class="c1">; fibonacci sequence :</span>
    <span class="c1">; f_0 = 0</span>
    <span class="c1">; f_1 = 1</span>
    <span class="c1">; f_n = f_(n-1) + f_(n-2)</span>

    <span class="c1">; store the index parameter in the stack</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">18</span><span class="p">],</span> <span class="nb">si</span>

    <span class="c1">; test the index value</span>
    <span class="nf">cmp</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">18</span><span class="p">],</span> <span class="mi">1</span>
    <span class="nf">je</span> <span class="nv">.L_if_n_1</span>
    <span class="nf">jg</span> <span class="nv">.L_else_n_gt1</span>
    
    <span class="nl">.L_if_n_0:</span> <span class="c1">; special case when n is 0, return 0</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="mi">0</span>
        <span class="nf">jmp</span> <span class="nv">end_if_n</span>

    <span class="nl">.L_if_n_1:</span> <span class="c1">; special case when n is 1, return 1</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="mi">1</span>
        <span class="nf">jmp</span> <span class="nv">end_if_n</span>

    <span class="nl">.L_else_n_gt1:</span> <span class="c1">; recursive case : compute f_(n-2) + f_(n-1)</span>

        <span class="c1">; compute f_(n-2)</span>
        <span class="nf">mov</span> <span class="nb">si</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">18</span><span class="p">]</span>
        <span class="nf">sub</span> <span class="nb">si</span><span class="p">,</span> <span class="mi">2</span>
        <span class="nf">call</span> <span class="nv">_compute_fibonacci_rec</span>
        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="nb">rax</span>

        <span class="c1">; compute f_(n-1)</span>
        <span class="nf">mov</span> <span class="nb">si</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">18</span><span class="p">]</span>
        <span class="nf">dec</span> <span class="nb">si</span>
        <span class="nf">call</span> <span class="nv">_compute_fibonacci_rec</span>
        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">rax</span>

        <span class="c1">; compute f_n = f_(n-2)+f_(n-1) in the rax register</span>
        <span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
        <span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>
        <span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>

    <span class="nl">.L_end_if_n:</span>

    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>

    <span class="nf">ret</span>

<span class="nl">_start:</span>

    <span class="nf">mov</span> <span class="nb">si</span><span class="p">,</span> <span class="mi">17</span>
    <span class="nf">call</span> <span class="nv">_compute_fibonacci_rec</span>

    <span class="c1">; exit</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">60</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">syscall</span>
</code></pre></div></div>

<h2 id="whats-next-">What’s next ?</h2>


    



<div class="post-tags">
  
</div>
  </div>

  
  <section class="comments">
    <!-- <h2>Comments</h2> -->
    <script src="https://giscus.app/client.js"
        data-repo="smbct/smbct.github.io"
        data-repo-id="R_kgDOL0ffhg"
        data-category="Announcements"
        data-category-id="DIC_kwDOL0ffhs4CfYJ5"
        data-mapping="title"
        data-strict="1"
        data-reactions-enabled="0"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
  </script>

  </section>

  <section class="related">
  <h2>Related Posts</h2>
  <ul class="posts-list">
    
  </ul>
</section>

</div>

    </main>

    <!-- Optional footer content -->

  </body>
</html>
