<!DOCTYPE html>
<html lang="en">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  

  <title>
    
      Assembly x86 programming 101 &#58 chapter 7, ASCII Mandelbrot &middot; smbct's blog
    
  </title>

  <!-- 
 -->

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="series_article">

    
    <div id="sidebar">
  <header>
    <div class="site-title">
      <a href="/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        smbct's blog
      </a>
    </div>
    <p class="lead">Notes on computer science, programming, society and more.</p>
  </header>
  <nav id="sidebar-nav-links">

  
    
      <a class="home-link "
          href="/">Blog</a>
    
  
  
  

  

  


  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  



  <!-- should be improved -->
  
  <a class="category-link "
          href="/pages/series.html">Series </a>
  

  


  
    
  

  
    
      <a class="category-link "
          href="/pages/about.html">About</a>
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">

  
    <a id="github-link"
       class="icon" title="Github Profile" aria-label="Github Profile"
       href="https://github.com/smbct">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 28" height="24" width="28"><path d="M12 2c6.625 0 12 5.375 12 12 0 5.297-3.437 9.797-8.203 11.391-0.609 0.109-0.828-0.266-0.828-0.578 0-0.391 0.016-1.687 0.016-3.297 0-1.125-0.375-1.844-0.812-2.219 2.672-0.297 5.484-1.313 5.484-5.922 0-1.313-0.469-2.375-1.234-3.219 0.125-0.313 0.531-1.531-0.125-3.187-1-0.313-3.297 1.234-3.297 1.234-0.953-0.266-1.984-0.406-3-0.406s-2.047 0.141-3 0.406c0 0-2.297-1.547-3.297-1.234-0.656 1.656-0.25 2.875-0.125 3.187-0.766 0.844-1.234 1.906-1.234 3.219 0 4.594 2.797 5.625 5.469 5.922-0.344 0.313-0.656 0.844-0.766 1.609-0.688 0.313-2.438 0.844-3.484-1-0.656-1.141-1.844-1.234-1.844-1.234-1.172-0.016-0.078 0.734-0.078 0.734 0.781 0.359 1.328 1.75 1.328 1.75 0.703 2.141 4.047 1.422 4.047 1.422 0 1 0.016 1.937 0.016 2.234 0 0.313-0.219 0.688-0.828 0.578-4.766-1.594-8.203-6.094-8.203-11.391 0-6.625 5.375-12 12-12zM4.547 19.234c0.031-0.063-0.016-0.141-0.109-0.187-0.094-0.031-0.172-0.016-0.203 0.031-0.031 0.063 0.016 0.141 0.109 0.187 0.078 0.047 0.172 0.031 0.203-0.031zM5.031 19.766c0.063-0.047 0.047-0.156-0.031-0.25-0.078-0.078-0.187-0.109-0.25-0.047-0.063 0.047-0.047 0.156 0.031 0.25 0.078 0.078 0.187 0.109 0.25 0.047zM5.5 20.469c0.078-0.063 0.078-0.187 0-0.297-0.063-0.109-0.187-0.156-0.266-0.094-0.078 0.047-0.078 0.172 0 0.281s0.203 0.156 0.266 0.109zM6.156 21.125c0.063-0.063 0.031-0.203-0.063-0.297-0.109-0.109-0.25-0.125-0.313-0.047-0.078 0.063-0.047 0.203 0.063 0.297 0.109 0.109 0.25 0.125 0.313 0.047zM7.047 21.516c0.031-0.094-0.063-0.203-0.203-0.25-0.125-0.031-0.266 0.016-0.297 0.109s0.063 0.203 0.203 0.234c0.125 0.047 0.266 0 0.297-0.094zM8.031 21.594c0-0.109-0.125-0.187-0.266-0.172-0.141 0-0.25 0.078-0.25 0.172 0 0.109 0.109 0.187 0.266 0.172 0.141 0 0.25-0.078 0.25-0.172zM8.937 21.438c-0.016-0.094-0.141-0.156-0.281-0.141-0.141 0.031-0.234 0.125-0.219 0.234 0.016 0.094 0.141 0.156 0.281 0.125s0.234-0.125 0.219-0.219z"></path>
</svg>

    </a>
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  

  <!-- Optional additional links to insert for icons links -->




<!-- index pages are treated separately to handle pagination -->


<!-- for other pages, the link to the translated page is in a file -->


<!-- When one of the link is not set, the corresponding flag cannot be clicked -->

<a id="icon_flag"
     class="icon_flag active"
     
     >
🇬🇧 <div></div>
</a>
<a id="icon_flag"
  class="icon_flag"
  
>
🇫🇷 <div></div>
</a>



</nav>

  <p>
  &copy; 2024.
  <a href="/LICENSE.md">MIT License.</a>
</p>

</div>
    

    <main class="container">
      <header>
  


<p class="back-link">
    <a href="/series/x86_64_assembly/headline.html"><span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>Assembly x86-64 programming 101</a>
</p>


  <h1 class="post-title">Assembly x86 programming 101 &#58 chapter 7, ASCII Mandelbrot</h1>
</header>
<div class="content">
  <div class="post-meta">
  
  <!-- Thanks to https://stackoverflow.com/questions/10714980/locale-specific-date-in-jekyll -->
  <span class="post-date">
    📅
    
      28 Jun 2024
    
  </span>

  • ⏲️
  <!-- taken from https://carlosbecker.com/posts/jekyll-reading-time-without-plugins/ -->

<span class="reading-time" title="Estimated read time">
  
  
    29 
    
      mins
    
  
</span>
  •
  
  🇬🇧
  

  <span class="post-categories">
    
      &bull;

      
      
      

      
        low-level programming assembly
      
    
  </span>
</div>



  <div class="post-body">
    <p>Although we already covered numerous basics in x86 assembly so far, one thing that has not been discussed yet is the use of <strong>floating point</strong> computation : namely numbers with a <strong>decimal</strong> part.
However when working with computers, we love integers 🥰! No rounding, no loss of precision, no <a href="https://softwareengineering.stackexchange.com/questions/310173/floating-point-absorption-phenomena-and-ulp">absorption problems</a>, etc..
Unfortunately, non-integer values arise in many real world problems hence it is rather useful to know a little bit about them.</p>

<p>In this post, we will write a program that draws an ASCII version of the Mandelbrot set.
The Mandelbrot set is a famous fractal that has been intensively rendered on computers in all of its shapes : with colors, in 3d, etc..
Its computation however relies on complex numbers arithmetic, it is hence necessary to manipulate floating point numbers 🏄.
We will see here how to draw an <a href="https://en.wikipedia.org/wiki/ASCII_art">ASCII</a> version of this fractal by relying on some basic floating point number operations in assembly.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Mandel_zoom_00_mandelbrot_set.jpg/1920px-Mandel_zoom_00_mandelbrot_set.jpg" alt="The Mandelbrot set" /></p>
<div class="custom_caption">
  <p>&gt; A colorized version of the Mandelbrot set.</p>
</div>

<h2 id="more-on-branching">More on branching</h2>

<p>Before diving into the world of floating points numbers, let’s add some details about branching in x86 assembly.
We have already used testing operations such as <code class="language-plaintext highlighter-rouge">cmp</code> and <code class="language-plaintext highlighter-rouge">test</code> in the previous chapters.
These were useful to write conditionals and loops thanks to branching instructions like <code class="language-plaintext highlighter-rouge">jge</code>.</p>

<h4 id="signed-comparisons">Signed comparisons</h4>

<p>There are however other branching instructions that we did not cover, such as <code class="language-plaintext highlighter-rouge">jbe</code> (jump if bellow or equal) or <code class="language-plaintext highlighter-rouge">ja</code> (jump above).
The reason why several instructions exist is that some of them perform <strong>signed</strong> comparisons.</p>

<p>Internally, the use of the comparison instructions such as <code class="language-plaintext highlighter-rouge">cmp</code> and <code class="language-plaintext highlighter-rouge">test</code> set internal flags that dictate the behavior of the branching instructions. 
To see that in practice, let’s create a simple example :</p>

<div class="code_frame">Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">43</span>
<span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">42</span>

<span class="nf">cmp</span> <span class="nb">al</span><span class="p">,</span> <span class="nb">bl</span>
<span class="nf">jle</span> <span class="nv">.L_endif</span>

<span class="c1">; if_no_jump</span>

    <span class="c1">; printing</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">jumping_str</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">printf</span>

<span class="nl">.L_endif:</span>

<span class="c1">; [...]</span>

<span class="nl">branching_str:</span>
    <span class="nf">.asciz</span> <span class="err">"</span><span class="nv">not</span> <span class="nv">jumping</span><span class="err">!\</span><span class="nv">n</span><span class="err">"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This code performs a comparison of the two 1-byte registers <code class="language-plaintext highlighter-rouge">al</code> and <code class="language-plaintext highlighter-rouge">bl</code> and then prints 🖨️ a string if the value in the first register <code class="language-plaintext highlighter-rouge">al</code> is lower or equal to the value in the second register <code class="language-plaintext highlighter-rouge">bl</code>.
If you test this program, you should observe that the comparison is not verified since <code class="language-plaintext highlighter-rouge">43 &gt; 42</code>, hence the string is printed to the terminal.</p>

<p>Now, let’s replace the value <code class="language-plaintext highlighter-rouge">43</code> by the value <code class="language-plaintext highlighter-rouge">150</code> : <code class="language-plaintext highlighter-rouge">mov al, 150</code>.
You will observe that the program now skips the printing instructions! 😱</p>

<p>The reason why is that the <code class="language-plaintext highlighter-rouge">jle</code> instruction performs a <strong>signed</strong> comparison.
Indeed, depending on wether the values are signed or not, they are not interpreted the same way.
Let’s run the program in gdb and add a breakpoint after the <code class="language-plaintext highlighter-rouge">mov</code> instructions.
If we print the <code class="language-plaintext highlighter-rouge">al</code> value with<code class="language-plaintext highlighter-rouge">p $al</code>, we should get : <code class="language-plaintext highlighter-rouge">1 = -106</code>!
We can see that by default, the <code class="language-plaintext highlighter-rouge">p</code> command interprets the value as signed.</p>

<p>We can then use the command <code class="language-plaintext highlighter-rouge">p/u $al</code> that outputs <code class="language-plaintext highlighter-rouge">150</code> : this time the value is interpreted as being unsigned.
As our value is coded on 1 byte, or 8 bits, the unsigned version can code values between <em>0</em> and <em>255</em> and
the signed version will however represent values between <em>-128</em> and <em>127</em>.
You can replace the value <code class="language-plaintext highlighter-rouge">150</code> in our code by <code class="language-plaintext highlighter-rouge">-106</code> and see that it has no effect as the binary code is the same!</p>

<p>Now we can replace the <code class="language-plaintext highlighter-rouge">jle</code> instruction with <code class="language-plaintext highlighter-rouge">jbe</code>.
Still with the value <code class="language-plaintext highlighter-rouge">150</code> for <code class="language-plaintext highlighter-rouge">al</code>, the program should now execute the printing operations as the <code class="language-plaintext highlighter-rouge">jbe</code> instruction performs an unsigned comparaison, and correctly interprets the value as <code class="language-plaintext highlighter-rouge">150</code> 👌.</p>

<h4 id="flags-registers">Flags registers</h4>

<p>Internally, the comparison instructions and the conditional branching instructions are connected through the flags register.
These flags are internally set by the comparison instructions and their values will act on the behavior of the jumps.</p>

<p>We will test it in GDB by re-setting the comparison instruction to <code class="language-plaintext highlighter-rouge">jle</code> in our code, in order to make the program jump.
We can then add a breakpoint to pause the program just before the <code class="language-plaintext highlighter-rouge">jle</code> instruction. 
The <code class="language-plaintext highlighter-rouge">p $eflags</code> command can give us information about the flags that are set to 1 : <code class="language-plaintext highlighter-rouge">$1 = [ PF AF IF OF ]</code>.
We can look at <a href="https://faydoc.tripod.com/cpu/jle.htm">this page</a> for instance to verify when the jump occurs with <code class="language-plaintext highlighter-rouge">jle</code>.
We can see that it can happen when <code class="language-plaintext highlighter-rouge">SF</code> (the sign flag) is different than <code class="language-plaintext highlighter-rouge">OF</code> (the overflow flag), which is the case here as <code class="language-plaintext highlighter-rouge">OF</code> is set to 1 but not <code class="language-plaintext highlighter-rouge">SF</code>.</p>

<p>On the other hand, we can see on the page that a jump occurs with the <code class="language-plaintext highlighter-rouge">jbe</code> instruction when <code class="language-plaintext highlighter-rouge">CF=1</code> or <code class="language-plaintext highlighter-rouge">ZF=1</code>.
If we modify our program again to set <code class="language-plaintext highlighter-rouge">al</code> to <code class="language-plaintext highlighter-rouge">41</code> and <code class="language-plaintext highlighter-rouge">bl</code> to <code class="language-plaintext highlighter-rouge">b42</code>, we can see that the jump occurs with <code class="language-plaintext highlighter-rouge">jbe</code>.
If we print the <code class="language-plaintext highlighter-rouge">$eflags</code> register as previously we obtain : <code class="language-plaintext highlighter-rouge">$1 = [ CF PF AF SF IF ]</code>.
We can see that <code class="language-plaintext highlighter-rouge">CF</code> (carry flag) is set to 1, which triggers the jump.</p>

<div class="collapse-panel">
  <div>
<label for="TLDR_1">Technical note 📝</label>
<input type="checkbox" name="" id="TLDR_1" /><span class="collapse-label"></span>
<div class="collapse-content">
      <p>The <code class="language-plaintext highlighter-rouge">cmp</code> instruction performs comparison with subtractions (and discards the result).
We can see with the print command the list of flags that are set in our code.
<code class="language-plaintext highlighter-rouge">OF</code> is the <a href="https://en.wikipedia.org/wiki/FLAGS_register">overflow flag</a>, meaning that the subtraction causes an overflow.
Indeed, if we interpret the values as signed, <code class="language-plaintext highlighter-rouge">al-bl = -106-42=-148</code> which is lower than <code class="language-plaintext highlighter-rouge">-128</code> meaning that the result is positive because the number of bits is not enough to code <code class="language-plaintext highlighter-rouge">-148</code>.</p>
    </div></div>
</div>

<h2 id="floating-point-operations-in-x86-assembly">Floating point operations in x86 assembly</h2>

<p>Manipulating non-integer numbers is a whole new world in assembly programming.
Indeed, these numbers are coded as “floating points” (<strong>floats</strong> for short), meaning the bits that code them are decomposed into 2 parts : the mantissa and the exponent.
The mantissa is an integer that is to be multiplied (scaled) by a negative power, hence the exponent.
Usually, as numbers are coded in binary, the base 2 is used for the exponent.</p>

<p><img src="https://numeral-systems.com/media/ieee-754/ieee-754-floating-point.webp" alt="A visualisation of how decimal numbers are represented." /></p>
<div class="custom_caption">
  <p>&gt; A visualisation of how decimal numbers are represented. Image coming from <a href="https://numeral-systems.com/ieee-754-converter/">this site</a>.</p>
</div>

<p>Floating points operations in processors are performed by a dedicated component called the <a href="https://en.wikipedia.org/wiki/Floating-point_unit"><strong>F</strong>loating <strong>P</strong>oint <strong>U</strong>nit</a> (FPU).
Hence, the assembly arithmetic instructions are completely separated from their analog integer ones.</p>

<h3 id="how-are-floats-implemented-in-c-">How are floats implemented in C ?</h3>

<p>One possible source of inspiration to see how we can perform theses operations is to look at the assembly codes automatically generated from a C code that performs floating pointes operations.
Let’s start with a simple example :</p>

<div class="code_frame"> C language | floating_points.c </div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

    <span class="kt">double</span> <span class="n">nbf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="p">;</span>
    <span class="n">nbf</span> <span class="o">=</span> <span class="n">nbf</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"result: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nbf</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>You can compile with GCC and run this program to verify that the printed value is <em>0.125</em>.
In thi example, we work with double precision floating point numbers, meaning these numbers are coded on 8 bytes.</p>

<p>We can now use GCC to produce x86 assembly code from this C program with the following command : <code class="language-plaintext highlighter-rouge">gcc -S floating_points.c -masm=intel -fdiagnostics-color=always -fverbose-asm -o floating_points.s</code>.
This command allows to create an assembly source file by using the same syntax as the one we employ, and by adding useful annotations regarding the original C code.</p>

<p>Without going into all the details of the resulting file, we can have a look at the sections where the comments refer to the 3 lines of our <code class="language-plaintext highlighter-rouge">main</code> function :</p>

<div class="code_frame"> Assembly x86-64 | floating_points.s </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="c1">; floating_points.c:9:     double nbfd = 0.25;</span>
    <span class="nf">.loc</span> <span class="mi">1</span> <span class="mi">9</span> <span class="mi">12</span>
    <span class="nf">movsd</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="nv">.LC0</span><span class="p">[</span><span class="nv">rip</span><span class="p">]</span>	<span class="c1">; tmp84,</span>
    <span class="nf">movsd</span>	<span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">8</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nv">xmm0</span>	<span class="c1">; nbfd, tmp84</span>

<span class="c1">; floating_points.c:10:     nbfd = nbfd * 0.5;</span>
    <span class="nf">.loc</span> <span class="mi">1</span> <span class="mi">10</span> <span class="mi">10</span>
    <span class="nf">movsd</span>	<span class="nv">xmm1</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">8</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp86, nbfd</span>
    <span class="nf">movsd</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="nv">.LC1</span><span class="p">[</span><span class="nv">rip</span><span class="p">]</span>	<span class="c1">; tmp87,</span>
    <span class="nf">mulsd</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm1</span>	<span class="c1">; tmp85, tmp86</span>
    <span class="nf">movsd</span>	<span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">8</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nv">xmm0</span>	<span class="c1">; nbfd, tmp85</span>

<span class="c1">; floating_points.c:11:     printf("result: %f\n", nbfd);</span>
    <span class="nf">.loc</span> <span class="mi">1</span> <span class="mi">11</span> <span class="mi">5</span>
    <span class="nf">mov</span>	<span class="nb">rax</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">8</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp88, nbfd</span>
    <span class="nf">movq</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="nb">rax</span>	<span class="c1">;, tmp88</span>
    <span class="nf">lea</span>	<span class="nb">rax</span><span class="p">,</span> <span class="nv">.LC2</span><span class="p">[</span><span class="nv">rip</span><span class="p">]</span>	<span class="c1">; tmp89,</span>
    <span class="nf">mov</span>	<span class="nb">rdi</span><span class="p">,</span> <span class="nb">rax</span>	<span class="c1">;, tmp89</span>
    <span class="nf">mov</span>	<span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>	<span class="c1">;,</span>
    <span class="nf">call</span>	<span class="nv">printf@PLT</span>	<span class="c1">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="vector-registers-and-arithmetic-operations">Vector registers and arithmetic operations</h4>

<p>Let’s focus on the first part of the code, that consists in loading the value <code class="language-plaintext highlighter-rouge">0.25</code> in the variable.
We see a new kind of register here : <code class="language-plaintext highlighter-rouge">xmm0</code>.</p>

<p>This register is actually part of a set of registers called <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">vector registers</a>.
These are employed for high performances floating point operations as they allow to perform the same operation on multiple floating point values at the same time!
In this chapter however, we will only use them sequentially.</p>

<p>We can see that the content of these registers can be stored in memory as we would do for other registers with the dedicated operation <code class="language-plaintext highlighter-rouge">movsd</code>.
In this case, as we declared a <code class="language-plaintext highlighter-rouge">double</code> variable in our C code, the value will be manipulated as a 8 bytes value (double precision).</p>

<p>If we now look at the next lines of the generated assembly code, we can see the an example of the floating point multiplication ✖️ with the <code class="language-plaintext highlighter-rouge">mulsd</code> operation (for 8 bytes values).
Although this look like an analog version of the integer operations, they are actually different as the floating points numbers are not coded the same way as integers.
For this reason, floating point multiplications are much slower than integer ones.</p>

<h4 id="calling-convention">Calling convention</h4>

<p>With a call to <code class="language-plaintext highlighter-rouge">printf</code> in our previous code, we can see an example of the calling convention with the presence of floating point numbers.
We can see that the <code class="language-plaintext highlighter-rouge">rdi</code> register contains the string that is printed before showing the decimal value, that does not change from our previous experience.
However, the decimal value is then not placed on the usual registers <code class="language-plaintext highlighter-rouge">rsi</code>, that follows for passing parameters.
Instead, the first vector register <code class="language-plaintext highlighter-rouge">xmm0</code> is used.</p>

<p>Previously, we have seen that the <code class="language-plaintext highlighter-rouge">eax</code> register must be set to 0 in order to call <code class="language-plaintext highlighter-rouge">printf</code>.
This time, it is set to the value 1 as we use one of them.</p>

<h2 id="binary-representation-of-floats">Binary representation of floats</h2>

<p>One interesting aspect of the previous code is that it helps understanding how floats are coded in binary.
To see this, we can look at line 2 where the decimal value (<em>0.25</em>) is loaded from memory to the <code class="language-plaintext highlighter-rouge">xmm0</code> register.
This redirect us to the symbol <code class="language-plaintext highlighter-rouge">.LC0</code> in the generated file <code class="language-plaintext highlighter-rouge">floating_points.s</code>, where the value is defined :</p>

<div class="code_frame"> Assembly x86-64 | floating_points.s </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="nl">.LC0:</span>
  <span class="nf">.long</span>	<span class="mi">0</span>
  <span class="nf">.long</span>	<span class="mi">1070596096</span>
  <span class="nf">.align</span> <span class="mi">8</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>At first, this seems to have nothing to do with our initial value <code class="language-plaintext highlighter-rouge">0.25</code>! 😯
To understand why, we can have a look at the memory in the program.</p>

<p>Let’s compile our C code in debug mode : <code class="language-plaintext highlighter-rouge">gcc -g floating_points.c -o floating_points</code> and run GDB.
We can then set a breakpoint once the value is loaded in memory : <code class="language-plaintext highlighter-rouge">b floating_points.c:10</code> and execute the <code class="language-plaintext highlighter-rouge">run</code> command to pause the program.
In the assembly code generated from C, we can see that, at line 8, the value <code class="language-plaintext highlighter-rouge">0.25</code> is moved to the stack at the address <code class="language-plaintext highlighter-rouge">rbp-8</code>.</p>

<p>We can use the command <code class="language-plaintext highlighter-rouge">p $rbp-8</code> to print the address that contains our value in the stack, which is <code class="language-plaintext highlighter-rouge">0x7fffffffdc58</code> in my case. 
Then, it is possible to inspect the memory at this address with <code class="language-plaintext highlighter-rouge">x/gt 0x7fffffffdc58</code> (the <code class="language-plaintext highlighter-rouge">t</code> parameter allows to see the value in binary and <code class="language-plaintext highlighter-rouge">g</code> specifies the number of bytes, which is <code class="language-plaintext highlighter-rouge">8</code> here as we work with <code class="language-plaintext highlighter-rouge">double</code> precision floats).
This gives :
<code class="language-plaintext highlighter-rouge">0011111111010000000000000000000000000000000000000000000000000000</code></p>

<p>To better understand how this relates to the value <code class="language-plaintext highlighter-rouge">0.25</code>, we can refer to this <a href="https://numeral-systems.com/ieee-754-converter/">website</a> that explains how it is represented in binary.
By entering the value <code class="language-plaintext highlighter-rouge">0.25</code> and by selecting the 64 bits mode (8 bytes), we can see that the binary code of the value is exactly what we saw in memory :</p>

<pre style="font-size:0.8rem;">
<span style="color: red;">0</span> <span style="color: blue;">01111111101</span> <span style="color: green;">0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</span>
</pre>

<p>Where the red part represents the sign, the blue part is for the exponent and the green part represents the mantissa.
This explains the strange integer value we saw above as the  binary representation of <code class="language-plaintext highlighter-rouge">1070596096</code> is :
<code class="language-plaintext highlighter-rouge">00111111110100000000000000000000</code><br />
which corresponds to the first 32 bits of <code class="language-plaintext highlighter-rouge">0.25</code>’s binary representation.
You can further play with these gdb commands and verify that for instance, by turning our value into <code class="language-plaintext highlighter-rouge">-0.25</code>, only the first bit (sign) of its representation is flipped.</p>

<h4 id="single-vs-double-precision-floats">Single vs Double precision floats</h4>

<p>For now in our C code, we only manipulate double precision floats, coded on 8 bytes (64 bits).
Now let’s replace the double variable to a float :</p>

<div class="code_frame"> C language </div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="kt">float</span> <span class="n">nbf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="p">;</span>
<span class="n">nbf</span> <span class="o">=</span> <span class="n">nbf</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"result: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nbf</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>And re-generate the corresponding assembly code :</p>

<div class="code_frame">Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="c1">; floating_points.c:9:     float nbfd = -0.25;</span>
    <span class="nf">.loc</span> <span class="mi">1</span> <span class="mi">9</span> <span class="mi">11</span>
    <span class="nf">movss</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="nv">.LC0</span><span class="p">[</span><span class="nv">rip</span><span class="p">]</span>	<span class="c1">; tmp85,</span>
    <span class="nf">movss</span>	<span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">4</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nv">xmm0</span>	<span class="c1">; nbfd, tmp85</span>

<span class="c1">; floating_points.c:10:     nbfd = nbfd * 0.5;</span>
    <span class="nf">.loc</span> <span class="mi">1</span> <span class="mi">10</span> <span class="mi">10</span>
    <span class="nf">movss</span>	<span class="nv">xmm1</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">4</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp87, nbfd</span>
    <span class="nf">movss</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="nv">.LC1</span><span class="p">[</span><span class="nv">rip</span><span class="p">]</span>	<span class="c1">; tmp88,</span>
    <span class="nf">mulss</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm1</span>	<span class="c1">; tmp86, tmp87</span>
    <span class="nf">movss</span>	<span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">4</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nv">xmm0</span>	<span class="c1">; nbfd, tmp86</span>

<span class="c1">; floating_points.c:11:     printf("result: %f\n", nbfd);</span>
    <span class="nf">.loc</span> <span class="mi">1</span> <span class="mi">11</span> <span class="mi">5</span>
    <span class="nf">pxor</span>	<span class="nv">xmm2</span><span class="p">,</span> <span class="nv">xmm2</span>	<span class="c1">; _1</span>
    <span class="nf">cvtss2sd</span>	<span class="nv">xmm2</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">4</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; _1, nbfd</span>
    <span class="nf">movq</span>	<span class="nb">rax</span><span class="p">,</span> <span class="nv">xmm2</span>	<span class="c1">; _1, _1</span>
    <span class="nf">movq</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="nb">rax</span>	<span class="c1">;, _1</span>
    <span class="nf">lea</span>	<span class="nb">rax</span><span class="p">,</span> <span class="nv">.LC2</span><span class="p">[</span><span class="nv">rip</span><span class="p">]</span>	<span class="c1">; tmp89,</span>
    <span class="nf">mov</span>	<span class="nb">rdi</span><span class="p">,</span> <span class="nb">rax</span>	<span class="c1">;, tmp89</span>
    <span class="nf">mov</span>	<span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>	<span class="c1">;,</span>
    <span class="nf">call</span>	<span class="nv">printf@PLT</span>	<span class="c1">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can see that the double precision floats operations from the previous code have been replaced by their single precision versions : <code class="language-plaintext highlighter-rouge">movsd</code> ➡️ <code class="language-plaintext highlighter-rouge">movss</code> and <code class="language-plaintext highlighter-rouge">mulss</code> ➡️ <code class="language-plaintext highlighter-rouge">mulsd</code>.
We also discover a new operation : <code class="language-plaintext highlighter-rouge">cvtss2sd</code> that allows to convert a single precision floats to a double precision one.
The reason why this instruction appears here is because the <code class="language-plaintext highlighter-rouge">printf</code> function only handles as parameters double precision floats 🤷.</p>

<blockquote>
  <p>We may note 📝 that such operation is not present for integer numbers.
Indeed, the floating point representation significantly differs between the single and double precision modes.
For integers however, the binary representation is basically the same and the conversion just consists in moving bits from one place to another ↔️.</p>
</blockquote>

<h4 id="from-integers-to-floats">From integers to floats</h4>

<p>One last useful aspect from floats is their conversion from and to integers.
Let’s try with a last piece of C code :</p>

<div class="code_frame"> C language </div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="n">val_int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">val_double</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">val_int</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">val_float</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">val_int</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This compiles to the following assembly instructions :</p>

<div class="code_frame">Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="c1">; floating_points.c:17:     int val_int = 42;</span>
    <span class="nf">.loc</span> <span class="mi">1</span> <span class="mi">17</span> <span class="mi">9</span>
    <span class="nf">mov</span>	<span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">16</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="mi">42</span>	<span class="c1">; val_int,</span>
<span class="c1">; floating_points.c:18:     double val_double = (double)val_int;</span>
    <span class="nf">.loc</span> <span class="mi">1</span> <span class="mi">18</span> <span class="mi">12</span>
    <span class="nf">pxor</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm0</span>	<span class="c1">; tmp84</span>
    <span class="nf">cvtsi2sd</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">16</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp84, val_int</span>
    <span class="nf">movsd</span>	<span class="kt">QWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">8</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nv">xmm0</span>	<span class="c1">; val_double, tmp84</span>
<span class="c1">; floating_points.c:19:     float val_float = (float)val_int;</span>
    <span class="nf">.loc</span> <span class="mi">1</span> <span class="mi">19</span> <span class="mi">11</span>
    <span class="nf">pxor</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm0</span>	<span class="c1">; tmp85</span>
    <span class="nf">cvtsi2ss</span>	<span class="nv">xmm0</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">16</span><span class="p">[</span><span class="nb">rbp</span><span class="p">]</span>	<span class="c1">; tmp85, val_int</span>
    <span class="nf">movss</span>	<span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="o">-</span><span class="mi">12</span><span class="p">[</span><span class="nb">rbp</span><span class="p">],</span> <span class="nv">xmm0</span>	<span class="c1">; val_float, tmp85</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We discover here two additional operations : <code class="language-plaintext highlighter-rouge">cvtsi2sd</code> and <code class="language-plaintext highlighter-rouge">cvtsi2ss</code>.
These are the operations that respectively converts integers to single and double precision floats by truncation.
By doing the opposite way, we can also identify the operations to convert from floats to integers.</p>

<h2 id="the-ascii-mandelbrot-set">The ASCII Mandelbrot set</h2>

<p>Let us now achieve our goal in this chapter : drawing the ASCII Mandelbrot set.
We will draw it in the terminal in ASCII, meaning the “pixels” will be represented by text characters.
This will be the simplest form of such drawing as no colors or shading will be used.</p>

<h3 id="the-mandelbrot-set--">The Mandelbrot set ? 🤔</h3>

<p>The Mandelbrot set is a set of points defined on the <a href="https://en.wikipedia.org/wiki/Complex_plane">complex plane</a>.
Drawing this set allows to visualize a complex mathematical object with chaotic borders.</p>

<p>We will draw a grid of characters to represent it in the terminal.
Each character of the grid will represent the 2d coordinate of a point in the complex plane.
We will define a function that, for each of the point, indicates if it belongs to the Mandelbrot set or not.</p>

<p>In order to avoid spending too much time on the mathematical aspects, we will use the naïve algorithm presented on <a href="https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set">this page</a> and simply translate it into assembly :</p>

<div class="code_frame"> pseudocode | from wikipedia : Plotting_algorithms_for_the_Mandelbrot_set </div>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>for each pixel (Px, Py) on the screen do
    x0 := scaled x coordinate of pixel (scaled to lie in the Mandelbrot X scale (-2.00, 0.47))
    y0 := scaled y coordinate of pixel (scaled to lie in the Mandelbrot Y scale (-1.12, 1.12))
    x := 0.0
    y := 0.0
    iteration := 0
    max_iteration := 1000
    while (x*x + y*y ≤ 2*2 AND iteration &lt; max_iteration) do
        xtemp := x*x - y*y + x0
        y := 2*x*y + y0
        x := xtemp
        iteration := iteration + 1
 
    color := palette[iteration]
    plot(Px, Py, color)
</pre></td></tr></tbody></table></code></pre></figure>

<p>In this algorithm, you may realize that the complex numbers are not properly present since their real part <em>x</em> and their imaginary part <em>y</em> are handled separately.
This will actually simplify the assembly implementation as complex numbers are not natively present.</p>

<p>We can see that the first step is the computation of the initial points, that are scaled from our grid “pixels” coordinates into the complex plane coordinates.
Then, for each initial point, the test consists in studying the convergence of a sequence 🌀 that depends on the coordinates.
In this pseudocode, the number of iteration is used to assign a color to the pixel.
In our case however, we will simply return a boolean value that indicates if wether the function has converged or not for a given initial value.</p>

<h3 id="the-draw_mandelbrot-function-️">The <code class="language-plaintext highlighter-rouge">draw_mandelbrot</code> function ✏️</h3>

<p>To organize our code, we will proceed similarly to the previous chapter by splitting it into two different functions.
We will start by writing a function <code class="language-plaintext highlighter-rouge">draw_mandelbrot</code> that iterates over the grid coordinates and print a character that depends on its convergence test :</p>

<div class="collapse-panel"><div>
<label for="code_1">Expand</label>
<input type="checkbox" name="" id="code_1" /><span class="collapse-label"></span>
<div class="extensible-content">
<div class="code_frame"> Assembly x86-64 | draw_mandelbrot </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
</pre></td><td class="code"><pre><span class="c1">; draw the ascii mandelbrot set</span>
<span class="c1">; edi: width</span>
<span class="c1">; esi: height</span>
<span class="nl">draw_mandelbrot:</span>

    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="c1">; stack allocation</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">40</span> <span class="c1">; 32 + 8</span>
    <span class="c1">; width: rbp-4, 4 bytes</span>
    <span class="c1">; height: rbp-8, 4 bytes</span>
    <span class="c1">; row index: rbp-12, 4 bytes</span>
    <span class="c1">; col index: rbp-16, 4 bytes</span>
    <span class="c1">; x0 mandelbrot: rbp-24, 8 bytes</span>
    <span class="c1">; y0 mandelbrot: rbp-32, 8 bytes</span>

    <span class="c1">; store the parameters</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="nb">edi</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">esi</span>

    <span class="c1">; preserving registers</span>
    <span class="nf">push</span> <span class="nb">rdi</span>
    <span class="nf">push</span> <span class="nb">rsi</span>
    <span class="nf">push</span> <span class="nb">rbx</span>

    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">],</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="mi">0</span>
    <span class="nl">.L_for_row:</span>

        <span class="c1">; compute y0</span>
        <span class="c1">; [...]</span>

        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="mi">0</span>
        <span class="nl">.L_for_col:</span>

            <span class="c1">; compute x0</span>
            <span class="c1">; [...]</span>

            <span class="c1">; test the point convergence</span>
            <span class="c1">; [...]</span>

            <span class="nf">test</span> <span class="nb">ax</span><span class="p">,</span> <span class="nb">ax</span>
            <span class="nf">jnz</span> <span class="nv">.L_if_not_converge</span> 

            <span class="c1">; .L_if_converge:</span>

                <span class="c1">; print a star</span>
                <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
                <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
                <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">star_character</span><span class="p">]</span>
                <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">1</span>
                <span class="nf">syscall</span>

                <span class="nf">jmp</span> <span class="nv">.L_end_if_converge</span>

            <span class="nl">.L_if_not_converge:</span>

                <span class="c1">; printing a space</span>
                <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
                <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
                <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">sp</span><span class="nv">ace_character</span><span class="p">]</span>
                <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">1</span>
                <span class="nf">syscall</span>

            <span class="nl">.L_end_if_converge:</span>

            <span class="nf">inc</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>
            <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
            <span class="nf">cmp</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>
            <span class="nf">jne</span> <span class="nv">.L_for_col</span>

        <span class="c1">; print a line return</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">new_line</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">1</span>
        <span class="nf">syscall</span>

        <span class="nf">inc</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
        <span class="nf">cmp</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>
        <span class="nf">jne</span> <span class="nv">.L_for_row</span>

    <span class="c1">; restoring preserved registers</span>
    <span class="nf">pop</span> <span class="nb">rbx</span>
    <span class="nf">pop</span> <span class="nb">rsi</span>
    <span class="nf">pop</span> <span class="nb">rdi</span>

    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>

    <span class="nf">ret</span>

<span class="nf">.data</span>

<span class="nl">star_character:</span>
    <span class="nf">.word</span> <span class="s">'*'</span>
<span class="nl">space_character:</span>
    <span class="nf">.word</span> <span class="s">' '</span>
<span class="nl">new_line:</span>
    <span class="nf">.word</span> <span class="err">'\</span><span class="nv">n</span><span class="err">'</span>

<span class="c1">; complex plane bounds</span>
<span class="c1">; [...]</span>
</pre></td></tr></tbody></table></code></pre></figure>

</div></div></div>

<p>The function takes as parameters the width and the height of the character grid.
Its structure is similar to what we saw in previous chapters : there are two nested loops to iterate over the rows and the columns respectively.</p>

<p>For each coordinate of the grid, the corresponding x0 and y0 values of the complex plane are computed.
In this program, we will work with double precision floats.
After computing the initial values, the algorithm calls the function that tests the convergence of the point.
Depending on the result, either a star character “*” or a blank character “ <i></i>” is printed in the terminal.
Here for simplicity we perform the printing operation 🖨️ through system calls as we did in the first chapter.</p>

<h4 id="constants-definition">Constants definition</h4>

<p>Our first step to compute the function is to add as constants the bounds of the complex plane.
The values are taken from the pseucode of the Wikipedia page.
They can be defined directly as floating point values the following way :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="c1">; complex plane bounds</span>
<span class="nl">min_x:</span>
    <span class="nf">.double</span> <span class="o">-</span><span class="mf">2.00</span>
<span class="nl">max_x:</span>
    <span class="nf">.double</span> <span class="mf">0.47</span>
<span class="nl">min_y:</span>
    <span class="nf">.double</span> <span class="o">-</span><span class="mf">1.12</span>
<span class="nl">max_y:</span>
    <span class="nf">.double</span> <span class="mf">1.12</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can then implement the computation of the floating point values <code class="language-plaintext highlighter-rouge">x0</code> and <code class="language-plaintext highlighter-rouge">y0</code>.
Starting with y0, what we need is to convert the column index into a decimal value between <em>0</em> and <em>1</em>.
Then, this value can be scaled in order to be lie in the provided bounds ([-1.12, 1.12]).</p>

<h4 id="computation-of-x0-and-y0">Computation of x0 and y0</h4>

<p>This step requires to simultaneously interact with floating point values and integer values (the column index in the grid height).
To convert an integer value into a floating point value, we will used the <code class="language-plaintext highlighter-rouge">cvtsi2sd</code> instruction which can be compared to a <strong>cast</strong> in C. 
This first part in the code loads the grid coordinate and the grid height as 8 bytes floats in the vector registers and then performs necessary arithmetic operations to scale the value :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="nl">.L_for_row:</span>

    <span class="c1">; compute y0</span>
    <span class="nf">cvtsi2sd</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span> <span class="c1">; load the row index as a 8 bytes float</span>
    <span class="nf">dec</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
    <span class="nf">cvtsi2sd</span> <span class="nv">xmm3</span><span class="p">,</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="c1">; load the height as a 8 bytes float</span>
    <span class="nf">inc</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
    <span class="nf">divsd</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="nv">xmm3</span> <span class="c1">; compute a y position in [0, 1]</span>
    <span class="nf">movsd</span> <span class="nv">xmm3</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">max_y</span><span class="p">]</span>
    <span class="nf">subsd</span> <span class="nv">xmm3</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">min_y</span><span class="p">]</span>
    <span class="nf">mulsd</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="nv">xmm3</span> <span class="c1">; scale the [0,1] position by (max_y-min-y)</span>
    <span class="nf">addsd</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">min_y</span><span class="p">]</span> <span class="c1">; add min_y to the position</span>
    <span class="nf">movsd</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">],</span> <span class="nv">xmm1</span> <span class="c1">; store y0</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The computation of x0 is done similarly :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="nl">.L_for_col:</span>

    <span class="c1">; compute x0</span>
    <span class="nf">cvtsi2sd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>
    <span class="nf">dec</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
    <span class="nf">cvtsi2sd</span> <span class="nv">xmm3</span><span class="p">,</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
    <span class="nf">inc</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
    <span class="nf">divsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm3</span>
    <span class="nf">movsd</span> <span class="nv">xmm3</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">max_x</span><span class="p">]</span>
    <span class="nf">subsd</span> <span class="nv">xmm3</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">min_x</span><span class="p">]</span>
    <span class="nf">mulsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm3</span>
    <span class="nf">addsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">min_x</span><span class="p">]</span>
    <span class="nf">movsd</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">],</span> <span class="nv">xmm0</span>
</pre></td></tr></tbody></table></code></pre></figure>

<blockquote>
  <p>📝 Note the as the function contains 2 nested for loops, the computation of the y0 and x0 are not done at the same place.
Indeed, as the first loop concerns the rows, it is not necessary to re-compute the y0 index for each iteration on the columns.
Since floating point computation is expensive, this can be further optimized by storing the x0 values in an array.</p>
</blockquote>

<p>We can already test this first code by calling <code class="language-plaintext highlighter-rouge">printf</code> at each column iteration in order to print our the two values <code class="language-plaintext highlighter-rouge">x0</code> and <code class="language-plaintext highlighter-rouge">y0</code>.
To do so, we will define a string with adequate formatters for floating point double precision values and pass parameters to <code class="language-plaintext highlighter-rouge">printf</code> as we saw previously :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="nl">.L_for_col:</span>

    <span class="c1">; compute x0</span>
    <span class="c1">; [...]</span>

    <span class="c1">; display x0 and y0</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">formatter</span><span class="p">]</span>
    <span class="nf">movsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
    <span class="nf">movsd</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">printf</span>

<span class="c1">; [...]</span>

<span class="nl">formatter:</span>
    <span class="nf">.asciz</span> <span class="err">"</span><span class="nv">x0</span><span class="p">,</span> <span class="nv">y0</span><span class="p">:</span> <span class="o">%</span><span class="nv">f</span><span class="p">,</span> <span class="o">%</span><span class="nv">f</span><span class="err">\</span><span class="nv">n</span><span class="err">"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here the values of <code class="language-plaintext highlighter-rouge">x0</code> and <code class="language-plaintext highlighter-rouge">y0</code> are taken from the stack memory.
You may notice that this time 2 floating point values are passed to <code class="language-plaintext highlighter-rouge">printf</code>, hence the value 2 stored in <code class="language-plaintext highlighter-rouge">eax</code>.</p>

<p>This code can already be tested to verify that the different values of <code class="language-plaintext highlighter-rouge">x0</code> (in range [-2., 0.47]) and <code class="language-plaintext highlighter-rouge">y0</code> (in range [-1.12, 1.12]) are displayed at each iteration.</p>

<h3 id="the-test_convergence-function">The <code class="language-plaintext highlighter-rouge">test_convergence</code> function</h3>

<p>Now that the main function is in place, it is time to write the convergence function.
For each different couple of (x0, y0) values, this function will perform some number of iterations in order to decide if, for the initial values, it converges or not, indicating whether the initial point belongs to the Mandelbrot set.</p>

<div class="collapse-panel"><div>
<label for="code_2">Expand</label>
<input type="checkbox" name="" id="code_2" /><span class="collapse-label"></span>
<div class="extensible-content">
<div class="code_frame"> Assembly x86-64 | test_convergence function </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre></td><td class="code"><pre><span class="c1">; test if a point converges in the Mandelbrot set</span>
<span class="c1">; param x0: xmm0</span>
<span class="c1">; param y0: xmm1</span>
<span class="c1">; return a boolean in ax</span>
<span class="nl">test_convergence:</span>

    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">56</span> <span class="c1">; 46 + 10</span>
    <span class="c1">; x0: rbp-8, 8 bytes</span>
    <span class="c1">; y0: rbp-16, 8 bytes</span>
    <span class="c1">; x: rbp-24, 8 bytes</span>
    <span class="c1">; y: rbp-32, 8 bytes</span>
    <span class="c1">; xtemp: rbp-40, 8 bytes</span>
    <span class="c1">; iter, rbp-44, 4 bytes</span>
    <span class="c1">; return flag, rbp-46, 2 bytes</span>

    <span class="c1">; preserving registers</span>
    <span class="nf">push</span> <span class="nb">rdi</span>
    <span class="nf">push</span> <span class="nb">rsi</span>
    <span class="nf">push</span> <span class="nb">rbx</span>

    <span class="c1">; save the parameters x0 and y0</span>
    <span class="nf">movsd</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nv">xmm0</span>
    <span class="nf">movsd</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="nv">xmm1</span>

    <span class="c1">; init x=0 and y=0</span>
    <span class="nf">xorps</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm0</span>
    <span class="nf">movsd</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">],</span> <span class="nv">xmm0</span>
    <span class="nf">movsd</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">],</span> <span class="nv">xmm0</span>

    <span class="c1">; init the return flag</span>
    <span class="nf">xor</span> <span class="nb">ax</span><span class="p">,</span> <span class="nb">ax</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">46</span><span class="p">],</span> <span class="nb">ax</span>

    <span class="c1">; init the iter variable</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">44</span><span class="p">],</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="mi">0</span>

    <span class="c1">; main loop for convergence test</span>
    <span class="nl">.L_for_conv:</span>

        <span class="c1">; test the convergence</span>
        <span class="c1">; [...]</span>

        <span class="c1">; .L_convergence_verified:</span>

            <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">46</span><span class="p">],</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="mi">1</span>
            <span class="nf">jmp</span> <span class="nv">.L_end_for</span>

        <span class="nl">.L_convergence_not_verified:</span>

        <span class="c1">; compute the next iteration</span>
        <span class="c1">; [...]</span>
        
        
        <span class="c1">; increase the iteration variable and test for the loop termination</span>
        <span class="nf">inc</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">44</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">max_iteration</span><span class="p">]</span>
        <span class="nf">cmp</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">44</span><span class="p">]</span>
        <span class="nf">jne</span> <span class="nv">.L_for_conv</span>

    <span class="nl">.L_end_for:</span>

    <span class="c1">; set the return flag</span>
    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">46</span><span class="p">]</span>

    <span class="c1">; restoring the preserved registers</span>
    <span class="nf">pop</span> <span class="nb">rbx</span>
    <span class="nf">pop</span> <span class="nb">rsi</span>
    <span class="nf">pop</span> <span class="nb">rdi</span>

    <span class="c1">; returning</span>
    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>
    <span class="nf">ret</span>
</pre></td></tr></tbody></table></code></pre></figure>

</div></div></div>

<p>As we previously did, we will define some constants to make the code simplify the code and make it more readable.
One integer constant will define the maximum number of iterations : <code class="language-plaintext highlighter-rouge">500</code>.
Two other constants define double precision floats that are used in the convergence algorithm : the value <code class="language-plaintext highlighter-rouge">4.</code>, to test the convergence, and the value <code class="language-plaintext highlighter-rouge">2.</code> to compute the new iteration :</p>

<div class="code_frame"> Assembly x86-64 | convergence constants </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="c1">; constants</span>
<span class="nl">max_iteration:</span>
    <span class="nf">.word</span> <span class="mi">500</span>
<span class="nl">double_4_cst:</span>
    <span class="nf">.double</span> <span class="mi">4</span><span class="nv">.</span>
<span class="nl">double_2_cst:</span>
    <span class="nf">.double</span> <span class="mi">2</span><span class="nv">.</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="computation-of-the-next-iteration-x-and-y">Computation of the next iteration <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code></h4>

<p>We can now write the code to compute the values of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> for the next iteration of the convergence test.
We will follow the pseudocode with 3 different steps : the computation of a temporary value <code class="language-plaintext highlighter-rouge">xtemp</code>, then the computation of the next <code class="language-plaintext highlighter-rouge">y</code> value and finally the computation of the new <code class="language-plaintext highlighter-rouge">x</code> value.</p>

<p>For the first step, we use simultaneously the two vector registers <code class="language-plaintext highlighter-rouge">xmm0</code> and <code class="language-plaintext highlighter-rouge">xmm1</code> in order to compute <code class="language-plaintext highlighter-rouge">x*x</code> and <code class="language-plaintext highlighter-rouge">y*y</code> without needing additional memory space :</p>

<div class="code_frame"> Assembly x86-64 | next iteration computation </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="c1">; compute the next iteration</span>

<span class="c1">; compute x_temp = x*x-y*y + x0</span>
<span class="nf">movsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
<span class="nf">mulsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span> <span class="c1">; xmm0 = x*x</span>
<span class="nf">movsd</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span>
<span class="nf">mulsd</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span> <span class="c1">; xmm1 = y*y</span>
<span class="nf">subsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm1</span> <span class="c1">; xmm0 = x*x-y*y</span>
<span class="nf">addsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="c1">; xmm0 = x*x-y*y + x0</span>
<span class="nf">movsd</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">40</span><span class="p">],</span> <span class="nv">xmm0</span> <span class="c1">; store x_temp = xmm0 = x*x-y*y + x0</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The computation of the new <code class="language-plaintext highlighter-rouge">y</code> value then uses only the <code class="language-plaintext highlighter-rouge">xmm0</code> register.
This is the place where the constant <code class="language-plaintext highlighter-rouge">2.0</code> defined earlier is used :</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="c1">; compute ynext = 2*x*y + y0</span>
<span class="nf">movsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">double_2_cst</span><span class="p">]</span> <span class="c1">; xmm0 = 2</span>
<span class="nf">mulsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span> <span class="c1">; xmm0 = 2*x</span>
<span class="nf">mulsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span> <span class="c1">; xmm0 = 2*x*y</span>
<span class="nf">addsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span> <span class="c1">; xmm0 = 2*x*y + y0</span>
<span class="nf">movsd</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">],</span> <span class="nv">xmm0</span> <span class="c1">; store y_next = 2*x*y + y0</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Finally, the new value of  <code class="language-plaintext highlighter-rouge">x</code> is copied from the <code class="language-plaintext highlighter-rouge">xtemp</code> variable to the stack’s memory.
It is necessary to use a temporary <code class="language-plaintext highlighter-rouge">xtemp</code> variable since the computation of the new <code class="language-plaintext highlighter-rouge">x</code> value depends on the <code class="language-plaintext highlighter-rouge">y</code> value :</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="c1">; compute x_next = xtemp</span>
<span class="nf">movsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">40</span><span class="p">]</span>
<span class="nf">movsd</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">],</span> <span class="nv">xmm0</span> <span class="c1">; store x_next = xtemp = x*x-y*y + x0</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="testing-the-convergence">Testing the convergence</h4>

<p>Finally, we can write the convergence test that allows to exit the convergence loop and return a positive answer.
The first part consists in computing <code class="language-plaintext highlighter-rouge">x*x+y*y</code>, which as done similarly to the computation of the next iteration values.
The comparison with the convergence constant <code class="language-plaintext highlighter-rouge">4.</code> is then performed by the (double precision) floating point instruction <code class="language-plaintext highlighter-rouge">comisd</code>:</p>

<div class="code_frame"> Assembly x86-64 | convergence test </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="c1">; test for convergence</span>

<span class="c1">; computation of x*x + y*y</span>
<span class="nf">movsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
<span class="nf">mulsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm0</span>
<span class="nf">movsd</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span>
<span class="nf">mulsd</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="nv">xmm1</span>
<span class="nf">addsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm1</span>

<span class="c1">; comparison of x*x+y*y and cst. 4.</span>
<span class="nf">movsd</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nv">rip</span><span class="o">+</span><span class="nv">double_4_cst</span><span class="p">]</span>
<span class="nf">comisd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm1</span>

<span class="c1">; branching if the convergence test is not verified</span>
<span class="nf">jbe</span>  <span class="nv">.L_convergence_not_verified</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>You will notice that the <code class="language-plaintext highlighter-rouge">jbe</code> instruction is used for branching here.
Indeed, the comparison instructions for floats set the <a href="https://stackoverflow.com/questions/7057501/x86-assembler-floating-point-compare">carry</a> <a href="http://www.ray.masmcode.com/tutorial/fpuchap7.htm#fcomex">flag</a> in the flags register.
According to what we saw in this chapter, the <code class="language-plaintext highlighter-rouge">jle</code> instruction would not trigger a jump regarding this flag.</p>

<h3 id="wrapping-it-up-and-testing-the-result">Wrapping it up and testing the result</h3>

<p>The last missing part of our code is the call to the <code class="language-plaintext highlighter-rouge">test_convergence</code> function in the <code class="language-plaintext highlighter-rouge">draw_mandelbrot</code> function :</p>

<div class="code_frame"> Assembly x86-64 </div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="nl">draw_mandelbrot:</span>

    <span class="c1">; [...]</span>

        <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">],</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="mi">0</span>
        <span class="nl">.L_for_col:</span>

            <span class="c1">; compute x0</span>
            <span class="c1">; [...]</span>

            <span class="c1">; test the point convergence</span>
            <span class="nf">xorps</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm0</span>
            <span class="nf">xorps</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="nv">xmm1</span>
            <span class="nf">movsd</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
            <span class="nf">movsd</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">32</span><span class="p">]</span>
            <span class="nf">call</span> <span class="nv">test_convergence</span>

    <span class="c1">; [...]        </span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We can now perform the final test of our code by calling the <code class="language-plaintext highlighter-rouge">draw_mandelbrot</code> function from a <code class="language-plaintext highlighter-rouge">main</code>.
In my implementation, I used a grid of size <code class="language-plaintext highlighter-rouge">80*30</code> which gives the following result :</p>

<div class="code_frame"> Bash </div>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>                                                         ******                 
                                                         ******                 
                                                           ***                  
                                               **  ******************           
                                                ***************************     
                                            *******************************     
                                          * *********************************   
                           *    *         ***********************************   
                           ***********   ***********************************    
                         *************** ***********************************    
                     *** *************************************************      
                     *** *************************************************      
                         *************** ***********************************    
                           ***********   ***********************************    
                           *    *         ***********************************   
                                          * *********************************   
                                            *******************************     
                                                ***************************     
                                               **  ******************           
                                                           ***                  
                                                         ******                 
                                                         ******                 
</pre></td></tr></tbody></table></code></pre></figure>

<p>Perfect! We can clearly see the Mandelbrot set here in our terminal! 🤓</p>

<h2 id="whats-next-">What’s next ?</h2>

<p>This chapter was the occasion to review several technical points in assembly and understand how floating points variables are handled.
The codes from the chapter is available at the followink <a href="https://github.com/smbct/x86-64_101_linux/tree/main/pt7_ascii_mandelbrot">link</a>.
By now, you should be able to implement any type of algorithm that can rely on the stack for its memory.
One of the most important thing here is the ability to autonomously debug the program, with gdb for instance.
This skill will help understanding more concepts and progress in assembly.
The following chapters will focus on applications of these different notions.</p>

    



<div class="post-tags">
  
</div>
  </div>

  

  
  <section class="comments">
    <!-- <h2>Comments</h2> -->
    <script src="https://giscus.app/client.js"
        data-repo="smbct/smbct.github.io"
        data-repo-id="R_kgDOL0ffhg"
        data-category="Announcements"
        data-category-id="DIC_kwDOL0ffhs4CfYJ5"
        data-mapping="title"
        data-strict="1"
        data-reactions-enabled="0"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
  </script>

  </section>


</div>




<p class="back-link">
    <a href="/series/x86_64_assembly/headline.html"><span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>Assembly x86-64 programming 101</a>
</p>


    </main>

    <!-- Optional footer content -->

  </body>
</html>
