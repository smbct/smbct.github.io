<!DOCTYPE html>
<html lang="en">

  <head>
  <link href="https://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  

  <title>
    
      Assembly x86-64 programming 101 &#58 chapter 5, printing arrays &middot; smbct's blog
    
  </title>

  <!-- 
 -->

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="series_article">

    
    <div id="sidebar">
  <header>
    <div class="site-title">
      <a href="/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        smbct's blog
      </a>
    </div>
    <p class="lead">Notes on computer science, society and more.</p>
  </header>
  <nav id="sidebar-nav-links">

  
    
      <a class="home-link "
          href="/">Blog</a>
    
  
  
  

  

  


  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  



  <!-- should be improved -->
  
  <a class="category-link "
          href="/pages/series.html">Series </a>
  

  


  
    
  

  
    
      <a class="category-link "
          href="/pages/about.html">About</a>
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">

  <a id="subscribe-link" class="icon" title="Subscribe" aria-label="Subscribe"
    href="/feed.xml">
    <svg fill="#000000" height="26" viewBox="0 0 24 24" width="26" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>

  </a>

  <a id="mastodon-link" class="icon" title="Mastodon" aria-label="Mastodon"
    href="https://social.linux.pizza/@smbct">
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" class="bi bi-mastodon" viewBox="0 0 16 16">
  <path d="M11.19 12.195c2.016-.24 3.77-1.475 3.99-2.603.348-1.778.32-4.339.32-4.339 0-3.47-2.286-4.488-2.286-4.488C12.062.238 10.083.017 8.027 0h-.05C5.92.017 3.942.238 2.79.765c0 0-2.285 1.017-2.285 4.488l-.002.662c-.004.64-.007 1.35.011 2.091.083 3.394.626 6.74 3.78 7.57 1.454.383 2.703.463 3.709.408 1.823-.1 2.847-.647 2.847-.647l-.06-1.317s-1.303.41-2.767.36c-1.45-.05-2.98-.156-3.215-1.928a4 4 0 0 1-.033-.496s1.424.346 3.228.428c1.103.05 2.137-.064 3.188-.189zm1.613-2.47H11.13v-4.08c0-.859-.364-1.295-1.091-1.295-.804 0-1.207.517-1.207 1.541v2.233H7.168V5.89c0-1.024-.403-1.541-1.207-1.541-.727 0-1.091.436-1.091 1.296v4.079H3.197V5.522q0-1.288.66-2.046c.456-.505 1.052-.764 1.793-.764.856 0 1.504.328 1.933.983L8 4.39l.417-.695c.429-.655 1.077-.983 1.934-.983.74 0 1.336.259 1.791.764q.662.757.661 2.046z"/>
</svg>

  </a>

  
    <a id="github-link"
       class="icon" title="Github Profile" aria-label="Github Profile"
       href="https://github.com/smbct">
      <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 28" height="22" width="22"><path d="M12 2c6.625 0 12 5.375 12 12 0 5.297-3.437 9.797-8.203 11.391-0.609 0.109-0.828-0.266-0.828-0.578 0-0.391 0.016-1.687 0.016-3.297 0-1.125-0.375-1.844-0.812-2.219 2.672-0.297 5.484-1.313 5.484-5.922 0-1.313-0.469-2.375-1.234-3.219 0.125-0.313 0.531-1.531-0.125-3.187-1-0.313-3.297 1.234-3.297 1.234-0.953-0.266-1.984-0.406-3-0.406s-2.047 0.141-3 0.406c0 0-2.297-1.547-3.297-1.234-0.656 1.656-0.25 2.875-0.125 3.187-0.766 0.844-1.234 1.906-1.234 3.219 0 4.594 2.797 5.625 5.469 5.922-0.344 0.313-0.656 0.844-0.766 1.609-0.688 0.313-2.438 0.844-3.484-1-0.656-1.141-1.844-1.234-1.844-1.234-1.172-0.016-0.078 0.734-0.078 0.734 0.781 0.359 1.328 1.75 1.328 1.75 0.703 2.141 4.047 1.422 4.047 1.422 0 1 0.016 1.937 0.016 2.234 0 0.313-0.219 0.688-0.828 0.578-4.766-1.594-8.203-6.094-8.203-11.391 0-6.625 5.375-12 12-12zM4.547 19.234c0.031-0.063-0.016-0.141-0.109-0.187-0.094-0.031-0.172-0.016-0.203 0.031-0.031 0.063 0.016 0.141 0.109 0.187 0.078 0.047 0.172 0.031 0.203-0.031zM5.031 19.766c0.063-0.047 0.047-0.156-0.031-0.25-0.078-0.078-0.187-0.109-0.25-0.047-0.063 0.047-0.047 0.156 0.031 0.25 0.078 0.078 0.187 0.109 0.25 0.047zM5.5 20.469c0.078-0.063 0.078-0.187 0-0.297-0.063-0.109-0.187-0.156-0.266-0.094-0.078 0.047-0.078 0.172 0 0.281s0.203 0.156 0.266 0.109zM6.156 21.125c0.063-0.063 0.031-0.203-0.063-0.297-0.109-0.109-0.25-0.125-0.313-0.047-0.078 0.063-0.047 0.203 0.063 0.297 0.109 0.109 0.25 0.125 0.313 0.047zM7.047 21.516c0.031-0.094-0.063-0.203-0.203-0.25-0.125-0.031-0.266 0.016-0.297 0.109s0.063 0.203 0.203 0.234c0.125 0.047 0.266 0 0.297-0.094zM8.031 21.594c0-0.109-0.125-0.187-0.266-0.172-0.141 0-0.25 0.078-0.25 0.172 0 0.109 0.109 0.187 0.266 0.172 0.141 0 0.25-0.078 0.25-0.172zM8.937 21.438c-0.016-0.094-0.141-0.156-0.281-0.141-0.141 0.031-0.234 0.125-0.219 0.234 0.016 0.094 0.141 0.156 0.281 0.125s0.234-0.125 0.219-0.219z"></path>
</svg>

    </a>
  

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/tags.html">
      <svg fill="#000000" height="26" viewBox="0 0 24 24" width="26" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>

    </a>
  

  

  <!-- Optional additional links to insert for icons links -->




<!-- index pages are treated separately to handle pagination -->


<!-- for other pages, the link to the translated page is in a file -->


<!-- When one of the link is not set, the corresponding flag cannot be clicked -->

<a id="icon_flag"
     class="icon_flag active"
     
     >
üá¨üáß <div></div>
</a>
<a id="icon_flag"
  class="icon_flag"
  
>
üá´üá∑ <div></div>
</a>



</nav>

  <p>
  &copy; 2025.
  <a href="/LICENSE.md">MIT License.</a>
</p>

</div>
    

    <main class="container">
      <header>
  


<p class="back-link">
    <a href="/series/x86_64_assembly/headline.html"><span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>Assembly x86-64 programming 101</a>
</p>


  <h1 class="post-title">Assembly x86-64 programming 101 &#58 chapter 5, printing arrays</h1>
</header>
<div class="content">
  <div class="post-meta">
  
  <!-- Thanks to https://stackoverflow.com/questions/10714980/locale-specific-date-in-jekyll -->
  <span class="post-date">
    üìÖ
    
      21 May 2024
    
  </span>

  ‚Ä¢ ‚è≤Ô∏è
  <!-- taken from https://carlosbecker.com/posts/jekyll-reading-time-without-plugins/ -->

<span class="reading-time" title="Estimated read time">
  
  
    17 
    
      mins
    
  
</span>
  ‚Ä¢
  
  üá¨üáß
  

  <span class="post-categories">
    
      &bull;

      
      
      

      
        low-level programming assembly
      
    
  </span>
</div>



  <div class="post-body">
    <p>The last post taught us how to write functions in x68 assembly.
The interesting thing is that now we can interact with compiled libraries from other languages.
This will allow us to perform higher level tasks such as opening windows, networking, etc‚Ä¶
In this post, we will start by looking at how to <strong>call C functions</strong>.
We will first see how to use the <code class="language-plaintext highlighter-rouge">printf</code> function in order to print variables üñ®Ô∏è.
This will let us print the content of an integer array in assembly.
We will also see how to create a function that can be called from a C program üîÑ!</p>

<h2 id="calling-the-c-printf-functions">Calling the C <code class="language-plaintext highlighter-rouge">printf</code> functions</h2>

<p>Although we previously had the freedom to decide our own convention about functions parameters and return value, calling a function from an external library requires us to follow the library‚Äôs convention.
We will see how to do so by calling the <code class="language-plaintext highlighter-rouge">printf</code> function from the C standard library.</p>

<h4 id="using-the-c-standard-lib-in-our-program">Using the C standard lib in our program</h4>

<p>Our program‚Äôs compilation will now change a bit.
Previously, we created executables that did not rely on any external library.
We will now need to link the standard library from C to be able to use <code class="language-plaintext highlighter-rouge">printf</code>.</p>

<p>Adding the C standard library to our programs is simply done by removing the option <code class="language-plaintext highlighter-rouge">-nostdlib</code> when linking the executable with gcc, as it is actually linked by default.
However, the C library adds a lot more features to our program : it defines the <code class="language-plaintext highlighter-rouge">_start</code> function (our program‚Äôs entry point) by itself.
For this reason, our program‚Äôs first function will now be the classical <code class="language-plaintext highlighter-rouge">main</code> function.</p>

<p>The ‚Äúhello world‚Äù code becomes :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">main</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="nl">main:</span>

    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">hello_world</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">14</span>
    <span class="nf">syscall</span>

    <span class="c1">; return</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">42</span>
    <span class="nf">ret</span>

<span class="nl">hello_world:</span>
    <span class="nf">.asciz</span> <span class="err">"</span><span class="nv">Hello</span><span class="p">,</span> <span class="nv">World</span><span class="err">!\</span><span class="nv">n</span><span class="err">"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are two changes regarding the previous ‚Äúhello_world‚Äù program : our function is now named <code class="language-plaintext highlighter-rouge">main</code> and it will be automatically be called by the <code class="language-plaintext highlighter-rouge">_start</code> function defined in the libc (C standard library) ; and since it is now a called function, the <code class="language-plaintext highlighter-rouge">ret</code> instruction is necessary at its end.
Also note that contrarily to what we saw previously, since our function does not use the stack ü•û we do not need to save and restore the <code class="language-plaintext highlighter-rouge">rsp</code> and <code class="language-plaintext highlighter-rouge">rbp</code> registers here.</p>

<p>The compilation is done as previously, except for the second command that becomes <code class="language-plaintext highlighter-rouge">gcc -static my_program.o -o my_program</code> (the <code class="language-plaintext highlighter-rouge">-nostdlib</code> option has been removed).
You can verify that the program‚Äôs output is actually <em>42</em>, which is indeed <code class="language-plaintext highlighter-rouge">main</code>‚Äôs return value : <code class="language-plaintext highlighter-rouge">./my_program ; echo $?</code>.</p>

<p>Note that if you try to compile any of our previous programs without the <code class="language-plaintext highlighter-rouge">-nostdlib</code> option, it would not work because the <code class="language-plaintext highlighter-rouge">_start</code> function would be defined twice.
If you want a more precise idea of the additional elements added to our programs by the standard libc, you might check this <a href="http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html">interesting article</a> üí°!</p>

<h4 id="passing-parameters-to-printf">Passing parameters to <code class="language-plaintext highlighter-rouge">printf</code></h4>

<p>Now that our code‚Äôs backbone is in place, let‚Äôs call the <code class="language-plaintext highlighter-rouge">printf</code> function.
Since the standard libc (C standard library) is now linked to our program, the <code class="language-plaintext highlighter-rouge">printf</code> symbol will be known by the linker.
Now the important thing is to see how to pass parameters to the <code class="language-plaintext highlighter-rouge">printf</code> functions.
That part is tricky : the (calling) convention used by Linux is called the <strong>AMD64 System V ABI</strong>.</p>

<p>Documentation is sometimes hard to find and I personally learned this from this <a href="https://stackoverflow.com/questions/38335212/calling-printf-in-x86-64-using-gnu-assembler">stackoverflow post</a>.
You can see that in this convention, registers are used for arguments and return values that are not <em>composed</em> data types.</p>

<p>Here is a summary of the order :</p>

<ul>
  <li>1st argument : <code class="language-plaintext highlighter-rouge">rdi</code></li>
  <li>2nd argument : <code class="language-plaintext highlighter-rouge">rsi</code></li>
  <li>3rd argument : <code class="language-plaintext highlighter-rouge">rdx</code></li>
  <li>4th argument : <code class="language-plaintext highlighter-rouge">rcx</code></li>
  <li>5th argument : <code class="language-plaintext highlighter-rouge">r8</code></li>
  <li>6th argument : <code class="language-plaintext highlighter-rouge">r9</code></li>
  <li>1st return value : <code class="language-plaintext highlighter-rouge">rax</code></li>
  <li>2nd return value : <code class="language-plaintext highlighter-rouge">rdx</code></li>
</ul>

<p>We can also learn that since <code class="language-plaintext highlighter-rouge">printf</code> has a variable number of arguments, the <code class="language-plaintext highlighter-rouge">al</code> register (the 8 bits version of <code class="language-plaintext highlighter-rouge">rax</code> register) must be set in order to give information about the use of specific registers.
In our case, we will only have to set it to <em>0</em>.</p>

<p>Following the convention, our <code class="language-plaintext highlighter-rouge">printf</code> call to print ‚Äúhello world‚Äù now becomes :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre>    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span> <span class="c1">; al is set to 0</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">hello_world</span><span class="p">]</span> <span class="c1">; 1st argument passed to register</span>
    <span class="nf">call</span> <span class="nv">printf</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If you try this, you would normally see a segmentation fault üôÅ</p>

<h4 id="one-more-requirement--stack-pointer-alignment-">One more requirement : stack pointer alignment ü•û</h4>

<p>By further reading the stackoverflow post that I linked above, we learn that there is one more condition that needs to be met when calling C functions in the <strong>AMD64 System V ABI</strong> convention : the stack pointer must be aligned to 16 bytes, meaning its value must be a multiple of 16.</p>

<p>We can run gdb on your program and check the value of <code class="language-plaintext highlighter-rouge">rsp</code> after entering the main function by adding a breakpoint in debug mode.
In my case, the value of <code class="language-plaintext highlighter-rouge">rsp</code> is <em>0x7fffffffdbb8</em>.
We then compute <code class="language-plaintext highlighter-rouge">print 0x7fffffffdbb8 % 0x10</code> (where <em>0x10</em> is 16 in hexadecimal).
The result should be <em>8</em> : hence we see that there is an 8 bytes misalignment of the <code class="language-plaintext highlighter-rouge">rsp</code> value.</p>

<blockquote>
  <p>üìù An easier way to check the alignment is by directly looking at the binary representation of the <code class="language-plaintext highlighter-rouge">rsp</code> pointer.
To do so, one can use the <code class="language-plaintext highlighter-rouge">p/t rsp</code> command in GDB.
In my case, I obtain : <code class="language-plaintext highlighter-rouge">$2 = [...]111101101110111000</code>.
Since 16 is a power of 2 (<em>16 = 2^4</em>), we can directly see if the value is a multiple of 16 by looking at the last 4 bits, which indicate wether there is an extra part between 0 and 15.
We can see that it is indeed the case.</p>
</blockquote>

<p>This misalignment comes from the fact that the <code class="language-plaintext highlighter-rouge">call</code> instruction that actually triggers the execution of <code class="language-plaintext highlighter-rouge">main</code> pushes the return address (8 bytes) to the stack, as we saw in the last chapter.
As a result the stack pointer is then misaligned by 8 bytes.
This can be fixed by simply re-aligning the stack pointer before starting the call, which can be done by ‚Äúallocating‚Äù 8 additional bytes (unused) :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre>    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">8</span>

    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span> <span class="c1">; al is set to 0</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">hello_world</span><span class="p">]</span> <span class="c1">; 1st argument passed to register</span>
    <span class="nf">call</span> <span class="nv">printf</span>

    <span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">8</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This should now work as expected! ü•≥
Note that since our string is zero terminated (it ends by ‚Äò\0‚Äô, as defined by the .asci<strong>z</strong> type with the gnu assembler), it is not necessary to specify its length to <code class="language-plaintext highlighter-rouge">printf</code>.</p>

<p>In our following codes, we will now make sure the stack pointer is well aligned before starting any operation in our functions.
A proper place to do it is when the local variables are allocated, as we saw in the previous post of the series.</p>

<p>This operation can also be done automatically by subtracting the offset : <code class="language-plaintext highlighter-rouge">rsp</code> modulo <em>8</em>, which can be performed by ‚Äúanding‚Äù <em>15</em> to the value of <code class="language-plaintext highlighter-rouge">rsp</code>: <code class="language-plaintext highlighter-rouge">and rsp, 15</code> (recall that a modulo operation on a power of two can be obtained by directly looking at the right number of bits in the binary representation).</p>

<h4 id="printing-integers-with-printf">Printing integers with printf</h4>

<p>Calling a C function is not easy!
The good thing is this is going to help us to bring concrete features to our programs.
Let‚Äôs start by accomplishing a task that was previously much harder : printing integer values!</p>

<p>To print a value in the terminal, we can use the <code class="language-plaintext highlighter-rouge">printf</code> function with its formatting abilities.
In our setup, <code class="language-plaintext highlighter-rouge">printf</code> would take as argument a string containing a formatter (which decides how the value is displayed) and the value to be printed.
We can have a look at the <a href="https://cplusplus.com/reference/cstdio/printf/">documentation</a> of <code class="language-plaintext highlighter-rouge">printf</code> to choose the correct formatter.
In C, this would look like :</p>

<div class="code_frame"> C language</div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>To do so in assembly, we start by defining a string that contains a formatter :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="nl">integer_formatter:</span>
    <span class="nf">.asciz</span> <span class="err">"</span><span class="nv">integer</span> <span class="nv">value</span><span class="p">:</span> <span class="o">%</span><span class="nv">i</span><span class="err">\</span><span class="nv">n</span><span class="err">"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The  ‚Äú%i‚Äù formatter is used to print a decimal integer.
We then call <code class="language-plaintext highlighter-rouge">printf</code> and pass this string as well as the value to be printed.
For this, we will use the <code class="language-plaintext highlighter-rouge">rsi</code> register, as it is dedicated to the second argument in the calling convention.</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre>    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">integer_formatter</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">rsi</span><span class="p">,</span> <span class="mi">42</span>
    <span class="nf">call</span> <span class="nv">printf</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The program should now print: ‚Äúinteger value: 42‚Äù.
This now adds a lot more possibilities to interact with the user!</p>

<h2 id="printing-an-array">Printing an array</h2>

<p>Now that we know how to call <code class="language-plaintext highlighter-rouge">printf</code>, we will create a function that will be useful for the future post : printing an array!
We start by defining a constant array in the program‚Äôs memory :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="nl">my_array:</span>
    <span class="nf">.byte</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">14</span>
<span class="nl">my_array_length:</span>
    <span class="nf">.word</span> <span class="mi">9</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In this case, the array elements are stored as bytes (8 bits long, coding integer values between -128 and 127).
We also define a constant indicating its size as a word (2 bytes).</p>

<p>We may now define our strings constants to be used by <code class="language-plaintext highlighter-rouge">printf</code> :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="nl">array_elt_formatter:</span>
    <span class="nf">.asciz</span> <span class="s">"%hhd "</span>
<span class="nl">new_line:</span>
    <span class="nf">.asciz</span> <span class="err">"\</span><span class="nv">n</span><span class="s">"
my_array_str:
    .asciz "</span><span class="nv">My</span> <span class="nv">array</span> <span class="p">:</span> <span class="err">"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">array_elt_formatter</code> is used to format a single byte as an integer with <code class="language-plaintext highlighter-rouge">printf</code>, followed by a space.
We also define the <code class="language-plaintext highlighter-rouge">new_line</code> string that only prints the return character for convenience, as well as a string announcing the array to be printed.</p>

<h4 id="the-local-variables">The local variables</h4>

<p>We will need 2 local variables in our <code class="language-plaintext highlighter-rouge">print_array</code> function : an 8-bytes variable to store the array address and a 2-bytes variable to store an index for iterating over the array.
This results in 10 bytes allocated on the stack ü•û.
With the 8 bytes already present to store the return address of the <code class="language-plaintext highlighter-rouge">main</code> function, the stack pointer would be aligned to 18 bytes.
Hence, 6 additional bytes are necessary to reach 32 bytes, for a 16 bytes alignment requirement (<em>32=2x16</em>).
This gives a total of 24 bytes to allocate.</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="nl">print_array:</span>

    <span class="c1">; storing the rsp value before local variables definition</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>
    <span class="c1">; rbp - 8 : array pointer, 8 bytes</span>
    <span class="c1">; rbp - 10 : array index, 2 bytes</span>
    <span class="c1">; 6 padding bytes</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">24</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The local variables are then initialized, and the first string announcing the array can be printed :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="mi">0</span> <span class="c1">; array_index &lt;- 0</span>
    <span class="c1">; loading the array pointer</span>
    <span class="nf">lea</span> <span class="nb">rax</span><span class="p">,</span> <span class="nv">my_array</span>
    <span class="nf">mov</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span> <span class="nb">rax</span>

    <span class="c1">; printing the "my_array_str" string</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_str</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">printf</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h4 id="writing-the-main-loop">Writing the main loop</h4>

<p>The main scheme here is similar to our <code class="language-plaintext highlighter-rouge">print_square</code> and <code class="language-plaintext highlighter-rouge">print_circle</code> programs from previous posts.
What changes is the call to <code class="language-plaintext highlighter-rouge">printf</code> and the array manipulation in order to extract its values.</p>

<p>Accessing the values of the array is performed by increasing üîº the array address.
Indeed, the address accessed through the label <code class="language-plaintext highlighter-rouge">my_array</code> actually points toward the first value of the array in the program‚Äôs memory.
Since the values are contiguous in memory, and since they are coded on 1 byte each, accessing the next value is performed by increasing the address by one (recall that the addresses are expressed as bytes).</p>

<p>Our main loop is as follows :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>    <span class="nl">.L_for_loop_writing:</span>
        <span class="c1">; printing the "my_array_str" string</span>
        <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
        <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">array_elt_formatter</span><span class="p">]</span>
        <span class="nf">mov</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="c1">; load the array pointer</span>
        <span class="nf">mov</span> <span class="nb">si</span><span class="nv">l</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">]</span> <span class="c1">; load the value stored at the address</span>
        <span class="nf">call</span> <span class="nv">printf</span>

        <span class="nf">inc</span> <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="c1">; increase the array pointer</span>
        <span class="nf">inc</span> <span class="kt">word</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="c1">; increase the array index</span>
        <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbp</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span>
        <span class="nf">cmp</span> <span class="nb">al</span><span class="p">,</span> <span class="p">[</span><span class="nv">my_array_length</span><span class="p">]</span>
        <span class="nf">jne</span> <span class="nv">for_loop_writing</span> <span class="c1">; test if all elements have been printed</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>You may notice that two steps are necessary to load a value from the array before calling <code class="language-plaintext highlighter-rouge">printf</code> : the address of the array must first be retrieved from the stack and then, the <code class="language-plaintext highlighter-rouge">mov</code> instruction is used to load the value coded at the address.
Note that the 1-byte register <code class="language-plaintext highlighter-rouge">sil</code> is used here to store the array values since they are encoded as single bytes.
These two steps cannot be concatenated into a single one since an instruction can have a memory reference in only one of its operand.</p>

<p>After the call to <code class="language-plaintext highlighter-rouge">printf</code>, the array index is increased as well as the array address.
Note the different prefixes as these two values are not coded on the same number of bytes.
Then, the index is compared to the array size, which is performed on two steps for the reason evoked just before.</p>

<p>Out <code class="language-plaintext highlighter-rouge">printing_array</code> function can be completed by printing a new line and then restoring the stack registers and exiting :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>    <span class="c1">; printing a new line</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">new_line</span><span class="p">]</span>
    <span class="nf">call</span> <span class="nv">printf</span>

    <span class="c1">; restoring the stack registers</span>
    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>
    <span class="nf">ret</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is it for printing the array!
We can execute this function from our <code class="language-plaintext highlighter-rouge">main</code> with a simple <code class="language-plaintext highlighter-rouge">call</code> instruction.</p>

<p>The next step for this code would be to give the array address and its size as parameters to the function : for instance using <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">si</code> (<code class="language-plaintext highlighter-rouge">rsi</code>) to pass the array pointer (namely the address) and the array length respectively.
I will leave it as an exercise and put the solution in the code repository.</p>

<h2 id="calling-a-custom-c-function">Calling a custom C function</h2>

<p>We will now see how we can write ‚úçÔ∏è our own C functions and call them from our assembly code.
This can be useful for instance to add functionalities to our assembly programs from external libraries.</p>

<p>We will start by writing a C function to print arrays, as we previously did in assembly :</p>

<div class="code_frame"> C language</div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">print_array_c</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">array</span><span class="p">,</span> <span class="kt">short</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>I added a return value to this function in order to test its interface with our assembly program.
In terms of calling convention, we have already seen that C functions use registers to pass some of the parameters.
Hence we can simply follow the register order given earlier in this post.</p>

<p>In this code, we choose the types <code class="language-plaintext highlighter-rouge">char</code> and <code class="language-plaintext highlighter-rouge">short</code> to store our data.
That is because in our assembly program, our array elements will be encoded on 1 byte each and the array size will be encoded on two bytes.
The size in bytes of the C variables types can be found <a href="https://en.wikipedia.org/wiki/C_data_types">online</a>.</p>

<p>We can then write our main function in assembly :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">main</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>
<span class="nl">main:</span>

    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="c1">; printing an array</span>
    <span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nv">my_array</span>
    <span class="nf">mov</span> <span class="nb">si</span><span class="p">,</span> <span class="nv">my_array_length</span>
    <span class="nf">call</span> <span class="nv">print_array_c</span>

    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>

    <span class="c1">; return</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">ret</span>

<span class="nl">my_array:</span>
    <span class="nf">.byte</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">14</span>

<span class="nl">my_array_length:</span>
    <span class="nf">.word</span> <span class="mi">9</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>That‚Äôs it! There are no extra steps required to call the C functions.
The <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">si</code> registers are used to pass parameters following the order of the convention given earlier.
Since the array length is encoded as a <code class="language-plaintext highlighter-rouge">word</code>, the 2-bytes version <code class="language-plaintext highlighter-rouge">si</code> of the <code class="language-plaintext highlighter-rouge">rsi</code> register is used.</p>

<p>To compile the program, we can first use the command <code class="language-plaintext highlighter-rouge">as assembly_code.s -o assembly_code.o</code> for the assembly code, then the command <code class="language-plaintext highlighter-rouge">gcc c_code.c -c -o c_code.o</code> for the C code.
We can finally create the final executable with the command <code class="language-plaintext highlighter-rouge">gcc -static assembly_code.o c_code.o -o my_program</code>, which should produce a working program!</p>

<p>You can test the presence of the symbols associated with our C functions in the executable : <code class="language-plaintext highlighter-rouge">strings my_program | grep print_array_c</code> should now return the name of our C function, showing that it is present in the final executable.
You can also compile in debug mode and set a breakpoint just after the return value to verify that the return value is correctly stored in the <code class="language-plaintext highlighter-rouge">ax</code> register.</p>

<h2 id="using-our-code-in-a-c-function">Using our code in a C function</h2>

<p>Our last part in this chapter is to go the other way around : calling an assembly function from a C program, a simple ‚Äúhello word‚Äù function in this case.
Once again, we will apply the calling convention for C programs.</p>

<p>We start by writing an assembly function that displays the ‚ÄúHello, World!‚Äù string thanks to a system call :</p>

<div class="code_frame"> Assembly x86-64</div>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="nf">.global</span> <span class="nv">_hello_world_assembly</span>
<span class="nf">.intel_syntax</span> <span class="nv">noprefix</span>

<span class="nl">_hello_world_assembly:</span>

    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>

    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">lea</span> <span class="nb">rsi</span><span class="p">,</span> <span class="p">[</span><span class="nv">hello_world_str</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">14</span>
    <span class="nf">syscall</span>

    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rbp</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>
    <span class="nf">ret</span>

<span class="nl">hello_world_str:</span>
    <span class="nf">.asciz</span> <span class="err">"</span><span class="nv">Hello</span><span class="p">,</span> <span class="nv">World</span><span class="err">!\</span><span class="nv">n</span><span class="err">"</span>
</pre></td></tr></tbody></table></code></pre></figure>

<!-- </div> -->

<p>Note that since this code is not the main program, there are no <code class="language-plaintext highlighter-rouge">main</code> or <code class="language-plaintext highlighter-rouge">_start</code> functions.
We can now write the C <code class="language-plaintext highlighter-rouge">main</code> to call this ‚Äúhello world‚Äù function.
The only extra step here consists in defining the function before calling it.
Without the definition, the compiler would complain.</p>

<div class="code_frame"> C language</div>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="kt">void</span> <span class="nf">_hello_world_assembly</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// call an assembly function</span>
    <span class="n">_hello_world_assembly</span><span class="p">();</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This program can be compiled the same away as previously : the assembly code is compiled with <code class="language-plaintext highlighter-rouge">as</code> and the C code is compiled with <code class="language-plaintext highlighter-rouge">gcc</code>.
Then, the object files are assembled into one executable that produces the intended output!</p>

<h2 id="whats-next-">What‚Äôs next ?</h2>

<p>This article is the final one about the basics of assembly.
Our programs can now perform more advanced functions by using external libraries.
The following posts will focus on concrete examples on the use of assembly language.</p>

<p>As done before, the codes from this post are available at the following <a href="https://github.com/smbct/x86-64_101_linux/tree/main/pt5_print_array">link</a>.</p>

    



<div class="post-tags">
  
</div>
  </div>

  

  
  <section class="comments">
    <!-- <h2>Comments</h2> -->
    <script src="https://giscus.app/client.js"
        data-repo="smbct/smbct.github.io"
        data-repo-id="R_kgDOL0ffhg"
        data-category="Announcements"
        data-category-id="DIC_kwDOL0ffhs4CfYJ5"
        data-mapping="title"
        data-strict="1"
        data-reactions-enabled="0"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
  </script>

  </section>


</div>




<p class="back-link">
    <a href="/series/x86_64_assembly/headline.html"><span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>Assembly x86-64 programming 101</a>
</p>


    </main>

    <!-- Optional footer content -->

  </body>
</html>
